This module contains the defintions of the "greedy" (left first) order among parse trees (ref Frisch's ICALP 2004).


```agda
{-# OPTIONS --rewriting #-}
module cgp.greedy.Order where

import cgp.RE as RE
open RE using (RE; ε ; $_`_ ; _●_`_ ; _+_`_ ; _*_`_ ; ε∉ ; ε∈  ; ε∈_+_  ; ε∈_<+_ ; ε∈_+>_ ; ε∈_●_ ; ε∈*  ; ε∈ε ; ε∉r→¬ε∈r ; ε∉fst ; ε∉snd ; ε∉$ ; ε∉_+_ ; ε∉? ; ε∈? )


import cgp.Utils as Utils
open Utils using (foldr++ys-map-λ_→[]-xs≡ys ; all-concat )


import cgp.Word as Word
open Word using ( _∈⟦_⟧ ; ε ;  $_ ; _+L_ ; _+R_ ; _●_⧺_ ; _* )


import cgp.ParseTree as ParseTree
open ParseTree using ( U; EmptyU ; LetterU ;  LeftU ; RightU ; PairU ; ListU ; flat ; unflat ; unflat∘proj₂∘flat ; flat∘unflat )

import cgp.PDInstance as PDI
open PDI using ( PDInstance ; pdinstance ; PDInstance* ; pdinstance* ;
  pdinstance-left; pdinstance-right;
  pdinstance-star; mkinjList ;
  pdinstance-fst ; mkinjFst ;
  pdinstance-snd ; mkinjSnd ; mk-snd-pdi
  ) 



import cgp.empty.AllEmptyParseTree as AllEmptyParseTree
open AllEmptyParseTree using ( mkAllEmptyU ; mkAllEmptyU-sound ; Flat-[] ; flat-[] )

import cgp.PDInstance as PDI
open PDI using ( PDInstance ; pdinstance ; PDInstance* ; pdinstance* ;
  pdinstance-left ; pdinstance-right 
  ) 



import cgp.greedy.PartialDerivative as PartialDerivative
open PartialDerivative using ( pdU[_,_] ; pdUConcat ;
  concatmap-pdinstance-snd ; zip-es-flat-[]-es  ; pdinstance-dist ; mkinjDist ; inv-dist-sound ; pdinstance-assoc ; mkinjAssoc ; inv-assoc-sound ; pdUMany[_,_]; pdUMany-aux ; advance-pdi*-with-c  ; compose-pdi-with
  ) 


import Data.Char as Char
open Char using (Char )

import Data.Nat as Nat
open Nat using ( ℕ ; suc ; zero )

import Data.Maybe as Maybe
open Maybe using (Maybe ; just ; nothing )

import Data.List as List
open List using (List ; _∷_ ; [] ; _++_ ; [_]; map; head; concatMap ; _∷ʳ_  )

import Data.List.Properties
open Data.List.Properties using (  ++-identityʳ ; ++-identityˡ ; ∷ʳ-++ ; ++-cancelˡ )


import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; refl; trans; sym; cong; cong-app; subst)
open Eq.≡-Reasoning using (begin_; step-≡;  step-≡-∣;  step-≡-⟩; _∎)


import Data.Product as Product
open Product using (Σ; _,_; ∃; Σ-syntax; ∃-syntax; _×_ )
open Σ using (proj₁ ; proj₂)

import Data.List.Relation.Unary.All as All
open All using (All ; _∷_ ; [] ; map)

import Relation.Nullary as Nullary 
import Relation.Nullary.Negation using (contradiction; contraposition)
open Nullary using (¬_)

import Relation.Nullary.Decidable as Decidable
open Decidable using
  ( Dec; yes; no; ⌊_⌋; True; toWitness; fromWitness; _×-dec_; _⊎-dec_; ¬?)

open import Function using (_∘_ ; flip)

```

Next we would like to show that the list of parse trees generated by `parseAll`
is sorted according to the greedy matching policy.
For instance in [Example ParseAll](../PartialDerivative.lagda.md#example-parseall),
we find that the two output parse trees are sorted according to the greedy matching
policy, as the word captured by the left sub tree in
`PairU (ListU [LetterU ’a’]) (ListU [])`

is longer than the one captured in

`PairU (ListU [], ListU [LetteU ’a’])`.


The following definition is adapted from adopted from [4].




### Definition 29 : Greedy ordering among parse trees

Let r be a non problematic regular expression

Let v₁ v₂ be parse trees of r.
We define the odering among v1 and v2 as follows


Note: r ⊢ v₁ > v₂ means v₁ is greedier than v₂ .

```agda
infix 4 _⊢_>_

data _⊢_>_ : ∀ ( r : RE ) → U r → U r → Set where
  seq₁ : ∀ { l r : RE } { loc : ℕ } { v₁ v₁'  : U l } { v₂ v₂' : U r }
    →   l ⊢ v₁ >  v₁'   -- for PD greedy, we need to replace the premise with len |v₁| > len |v₂|
    ------------------------------------------------------------------
    →  ( l ● r ` loc) ⊢ (PairU v₁ v₂) > (PairU v₁' v₂')

  seq₂ : ∀ { l r : RE } { loc : ℕ } { v₁ v₁'  : U l } { v₂ v₂' : U r }
    → v₁ ≡ v₁'
    → r ⊢ v₂ > v₂'
    -------------------------------------------------------------------
    →  ( l ● r ` loc) ⊢ (PairU v₁ v₂) > (PairU v₁' v₂')


  choice-lr : ∀ { l r : RE } { loc : ℕ } { v₁ : U l } { v₂ : U r }
    → ( l + r ` loc ) ⊢ (LeftU v₁) > (RightU v₂)


  choice-ll : ∀ { l r : RE } { loc : ℕ } { v₁ v₁'  : U l } 
    →  l ⊢ v₁ >  v₁'
    -------------------------------------------------------------------
    → ( l + r ` loc ) ⊢ (LeftU v₁) > (LeftU v₁')


  choice-rr : ∀ { l r : RE } { loc : ℕ } { v₂ v₂'  : U r } 
    →  r ⊢ v₂ >  v₂'
    -------------------------------------------------------------------
    → ( l + r ` loc ) ⊢ (RightU v₂) > (RightU v₂')


  star-cons-nil : ∀ { r : RE } { loc : ℕ } { nε : ε∉ r } { v : U r } { vs : List (U r) }
    → ( r * nε ` loc ) ⊢ (ListU (v ∷ vs)) > ( ListU [] )
    

  star-head : ∀ { r : RE } { loc : ℕ } { nε : ε∉ r } { v₁ v₂ : U r } { vs₁ vs₂ : List (U r) }
    → r ⊢ v₁ > v₂
    ----------------------------------------------------------------------
    → ( r * nε ` loc ) ⊢ (ListU (v₁ ∷ vs₁)) > (ListU (v₂ ∷ vs₂))


  star-tail : ∀ { r : RE } { loc : ℕ } { nε : ε∉ r } { v₁ v₂ : U r } { vs₁ vs₂ : List (U r) }
    → v₁ ≡ v₂
    → ( r * nε ` loc ) ⊢ (ListU vs₁) > (ListU vs₂)
    ----------------------------------------------------------------------
    → ( r * nε ` loc ) ⊢ (ListU (v₁ ∷ vs₁)) > (ListU (v₂ ∷ vs₂))


```

Note : The > order is transitive. 

```agda
>-trans : { r : RE } { u₁ u₂ u₃ : U r }
  → r ⊢ u₁ > u₂
  → r ⊢ u₂ > u₃
  -----------------
  → r ⊢ u₁ > u₃
>-trans {ε} = λ()
>-trans {$ c ` loc} = λ()
>-trans {r * ε∉r ` loc} star-cons-nil = λ()
>-trans {r * ε∉r ` loc} (star-head v₁>v₂)         (star-head v₂>v₃)  = star-head (>-trans v₁>v₂ v₂>v₃)
>-trans {r * ε∉r ` loc} (star-head v₁>v₂)         (star-tail v₂≡v₃ vs₂>vs₃) rewrite (sym v₂≡v₃) = star-head v₁>v₂
>-trans {r * ε∉r ` loc} (star-head v₁>v₂)         star-cons-nil  = star-cons-nil
>-trans {r * ε∉r ` loc} (star-tail v₁≡v₂ vs₁>vs₂) (star-tail v₂≡v₃ vs₂>vs₃) rewrite (sym v₂≡v₃) = star-tail v₁≡v₂ (>-trans vs₁>vs₂ vs₂>vs₃)
>-trans {r * ε∉r ` loc} (star-tail v₁≡v₂ vs₁>vs₂) (star-head v₂>v₃) rewrite v₁≡v₂ = star-head v₂>v₃ 
>-trans {r * ε∉r ` loc} (star-tail v₁≡v₂ vs₁>vs₂) star-cons-nil  = star-cons-nil
>-trans {l + r ` loc }  choice-lr                 (choice-rr v₂>v₃) = choice-lr 
>-trans {l + r ` loc }  (choice-rr v₁>v₂)         (choice-rr v₂>v₃) = choice-rr (>-trans v₁>v₂ v₂>v₃)
>-trans {l + r ` loc }  (choice-ll v₁>v₂)         (choice-ll v₂>v₃) = choice-ll (>-trans v₁>v₂ v₂>v₃)
>-trans {l + r ` loc }  (choice-ll v₁>v₂)         choice-lr         = choice-lr
>-trans {l ● r ` loc }  (seq₁ v₁>v₂)              (seq₁ v₂>v₃)      = seq₁ (>-trans v₁>v₂ v₂>v₃) 
>-trans {l ● r ` loc }  (seq₁ v₁>v₂)              (seq₂ v₂≡v₃ v₂'>v₃') rewrite (sym v₂≡v₃) = seq₁ v₁>v₂
>-trans {l ● r ` loc }  (seq₂ v₁≡v₂ v₁'>v₂')      (seq₂ v₂≡v₃ v₂'>v₃') rewrite (sym v₂≡v₃) = seq₂ v₁≡v₂ (>-trans v₁'>v₂' v₂'>v₃')
>-trans {l ● r ` loc }  (seq₂ v₁≡v₂ v₁'>v₂')      (seq₁ v₂>v₃)         rewrite v₁≡v₂ =  seq₁ v₂>v₃ 
```

Lemma u₁ > u₂ implies ¬ u₁ ≡ u₂


```agda
>→¬≡ : { r : RE } { u₁ u₂ : U r }
  → r ⊢ u₁ > u₂ 
  -----------------
  → ¬ u₁ ≡ u₂ 
>→¬≡ {ε} {EmptyU}    {EmptyU} = λ() 
>→¬≡ {$ c ` loc}     {LetterU _} {LetterU _} = λ()
-- >→¬≡ {r * ε∉r ` loc} {ListU []} {_} = λ()
>→¬≡ {r * ε∉r ` loc} {ListU (u ∷ us)} {ListU []} star-cons-nil = λ ()
>→¬≡ {r * ε∉r ` loc} {ListU (u ∷ us)} {ListU (v ∷ vs)} (star-head u>v) = λ list-u∷us≡list-v∷vs → ¬u≡v (proj₁ (ParseTree.inv-listU u us v vs list-u∷us≡list-v∷vs)) 
  where
    ¬u≡v : ¬ u ≡ v
    ¬u≡v = >→¬≡ {r} {u} {v} u>v
>→¬≡ {r * ε∉r ` loc} {ListU (u ∷ us)} {ListU (v ∷ vs)} (star-tail u≡v list-us>list-vs) = λ list-u∷us≡list-v∷vs → ¬us≡vs (proj₂ (ParseTree.inv-listU u us v vs list-u∷us≡list-v∷vs))
  where
    ¬list-us≡list-vs : ¬ (ListU us) ≡ (ListU vs)
    ¬list-us≡list-vs = >→¬≡ {r * ε∉r ` loc} {ListU us} {ListU vs} list-us>list-vs

    ¬us≡vs : ¬ us ≡ vs
    ¬us≡vs us≡vs = ¬list-us≡list-vs list-us≡list-vs
      where
        list-us≡list-vs : (ListU {r} {ε∉r} {loc} us) ≡ (ListU {r} {ε∉r} {loc} vs)
        list-us≡list-vs rewrite (cong (λ x → ListU {r} {ε∉r} {loc} x) us≡vs ) = refl 
>→¬≡ {l ● r ` loc} {PairU u₁ u₂} {PairU v₁ v₂} (seq₁ u₁>v₁) = λ pair-u₁u₂≡pair-v₁v₂ → ¬u₁≡v₁ (proj₁ (ParseTree.inv-pairU u₁ u₂ v₁ v₂ pair-u₁u₂≡pair-v₁v₂))
  where
    ¬u₁≡v₁ : ¬ u₁ ≡ v₁
    ¬u₁≡v₁ = >→¬≡ {l} {u₁} {v₁} u₁>v₁
>→¬≡ {l ● r ` loc} {PairU u₁ u₂} {PairU v₁ v₂} (seq₂ u₁≡v₁ u₂>v₂) = λ pair-u₁u₂≡pair-v₁v₂ → ¬u₂≡v₂ (proj₂ (ParseTree.inv-pairU u₁ u₂ v₁ v₂ pair-u₁u₂≡pair-v₁v₂))
  where
    ¬u₂≡v₂ : ¬ u₂ ≡ v₂
    ¬u₂≡v₂ = >→¬≡ {r} {u₂} {v₂} u₂>v₂
>→¬≡ {l + r ` loc} {LeftU u} {RightU v} choice-lr = λ () 
>→¬≡ {l + r ` loc} {LeftU u} {LeftU v} (choice-ll u>v) = λ left-u≡left-v →  ¬u≡v (ParseTree.inv-leftU u v left-u≡left-v)
  where 
    ¬u≡v : ¬ u ≡ v
    ¬u≡v = >→¬≡ {l} {u} {v} u>v
>→¬≡ {l + r ` loc} {RightU u} {RightU v} (choice-rr u>v) = λ right-u≡right-v →  ¬u≡v (ParseTree.inv-rightU u v right-u≡right-v)
  where 
    ¬u≡v : ¬ u ≡ v
    ¬u≡v = >→¬≡ {r} {u} {v} u>v
```

Lemma u₁ > u₂ implies ¬ u₂ > u₁

```agda
u>v→¬v>u : { r : RE } { u v : U r }
  → r ⊢ u > v 
  -----------------
  → ¬ r ⊢ v > u
u>v→¬v>u {ε}             {EmptyU} {EmptyU} = λ()
u>v→¬v>u {$ c ` loc}     {LetterU _} {LetterU _} = λ()
u>v→¬v>u {r * ε∉r ` loc} {ListU (u ∷ us)} {ListU []} star-cons-nil = λ ()
u>v→¬v>u {r * ε∉r ` loc} {ListU (u ∷ us)} {ListU (v ∷ vs)} (star-head u>v) list-v∷vs>list-u∷us with list-v∷vs>list-u∷us
... | star-head v>u = (u>v→¬v>u u>v) v>u
... | star-tail v≡u _ = (>→¬≡ u>v) (sym v≡u)
u>v→¬v>u {r * ε∉r ` loc} {ListU (u ∷ us)} {ListU (v ∷ vs)} (star-tail u≡v list-us>list-vs) list-v∷vs>list-u∷us with list-v∷vs>list-u∷us
... | star-head v>u = (>→¬≡ v>u) (sym u≡v)
... | star-tail v≡u list-vs>list-us = (u>v→¬v>u list-us>list-vs) list-vs>list-us
u>v→¬v>u {l ● r ` loc} {PairU u₁ u₂} {PairU v₁ v₂} (seq₁ u₁>v₁)  pair-v₁v₂>pair-u₁u₂ with pair-v₁v₂>pair-u₁u₂ 
... | seq₁ v₁>u₁   = (u>v→¬v>u u₁>v₁) v₁>u₁
... | seq₂ v₁≡u₁ _ = (>→¬≡ u₁>v₁) (sym v₁≡u₁)
u>v→¬v>u {l ● r ` loc} {PairU u₁ u₂} {PairU v₁ v₂} (seq₂ u₁≡v₁ u₂>v₂)  pair-v₁v₂>pair-u₁u₂ with pair-v₁v₂>pair-u₁u₂
... | seq₁ v₁>u₁   = (>→¬≡ v₁>u₁) (sym u₁≡v₁) 
... | seq₂ v₁≡u₁ v₂>u₂ = (u>v→¬v>u u₂>v₂) v₂>u₂
u>v→¬v>u {l + r ` loc} {LeftU u} {RightU v} choice-lr = λ ()
u>v→¬v>u {l + r ` loc} {LeftU u} {LeftU v} (choice-ll u>v) (choice-ll v>u) = (u>v→¬v>u u>v) v>u
u>v→¬v>u {l + r ` loc} {RightU u} {RightU v} (choice-rr u>v) (choice-rr v>u) = (u>v→¬v>u u>v) v>u 
```


### Example Greedy Order

For exapmle we find that

```agda
module ExampleGreedy where
  
  a*●a* : RE
  a*●a* = ( ( $ 'a' ` 1 ) * ε∉$ ` 2 ) ● ( ( $ 'a' ` 3 ) * ε∉$ ` 4 ) ` 5

  t1 : U a*●a*
  t1 = PairU (ListU (LetterU 'a' ∷ [])) (ListU [])

  t2 : U a*●a*
  t2 = PairU (ListU []) (ListU (LetterU 'a' ∷ []))

  t1>t2 : a*●a* ⊢  t1 > t2 
  t1>t2 = seq₁ star-cons-nil  
```


### Definition 30: >-sortedness 


```agda
data >-maybe : ∀ { r : RE } ( u : U r ) → ( mv : Maybe (U r) ) → Set where 
  >-nothing : ∀ { r : RE }
    → { u : U r } 
    ------------------------ 
    → >-maybe {r} u nothing

  >-just : ∀ { r : RE }
    → { u : U r }
    → { v : U r }
    → r ⊢ u > v 
    ---------------------------
    → >-maybe {r} u (just v)


data >-sorted : ∀ { r : RE } ( us : List (U r) ) → Set where
  >-nil : ∀ { r : RE } → >-sorted {r} []
  >-cons : ∀ { r : RE }
    → { u : U r }
    → { us : List (U r) }
    → >-sorted {r} us
    → >-maybe {r} u (head us)
    --------------------------
    → >-sorted {r} ( u ∷ us  )


-- concatenating two >-sorted lists of parse trees  yields a >-sorted list.
concat-sorted : ∀ { r : RE } 
  → ( us₁ : List ( U r ) )
  → ( us₂ : List ( U r ) )
  → >-sorted { r } us₁
  → >-sorted { r } us₂
  → All (λ u₁ → >-maybe {r} u₁ (head us₂)) us₁
  ----------------------------------------------
  → >-sorted { r } (us₁ ++ us₂)
concat-sorted []               us₂        >-nil        us₂-sorted    []                            = us₂-sorted
concat-sorted us₁              []         us₁-sorted   >-nil         _  rewrite (++-identityʳ us₁) = us₁-sorted
concat-sorted (u₁ ∷ [])        (u₂ ∷ us₂) us₁-sorted   u₂us₂-sorted  (>-just u₁>u₂ ∷ [] )          = >-cons u₂us₂-sorted (>-just u₁>u₂)
concat-sorted (u₁ ∷ u₁' ∷ us₁) (u₂ ∷ us₂) (>-cons u₁'us₁-sorted (>-just u₁>u₁'))  u₂us₂-sorted (>-just u₁>u₂ ∷ pxs) = >-cons ind-hyp (>-just u₁>u₁')
  where
    ind-hyp = concat-sorted (u₁' ∷ us₁) (u₂ ∷ us₂) u₁'us₁-sorted u₂us₂-sorted pxs


```



### Lemma 31: Parse trees generated by mkAllEmptyU is greedily sorted. (Lemma 20 from [2])

Let r be a non problematic regular expression, such that ε∈r.
Then (mkAllEmptyU ε∈r) is greedily sorted. 



#### Sub Lemma 31.1 - 31.4 : >-sortedness is preserved inductively over the parse tree constructors and construction operations.

```agda
-----------------------------------------------------------------------------
-- Sub Lemma 31.1 - 31.4  BEGIN
----------------------------------------------------------------------------
map-leftU-sorted : ∀ { l r : RE } { loc : ℕ }
  → ( us : List (U l) )
  → >-sorted {l} us
  → >-sorted {l + r ` loc } (List.map LeftU us)
map-leftU-sorted []          >-nil = >-nil
map-leftU-sorted ( u ∷ [] ) (>-cons >-nil >-nothing )
  = >-cons >-nil >-nothing
map-leftU-sorted ( u ∷ (v ∷ us) ) (>-cons >-sorted-us (>-just u>v))
  = >-cons (map-leftU-sorted (v ∷ us) >-sorted-us)
           (>-just (choice-ll u>v))


map-rightU-sorted : ∀ { l r : RE } { loc : ℕ }
  → ( us : List (U r) )
  → >-sorted {r} us
  → >-sorted {l + r ` loc } (List.map RightU us)
map-rightU-sorted []          >-nil = >-nil
map-rightU-sorted ( u ∷ [] ) (>-cons >-nil >-nothing )
  = >-cons >-nil >-nothing
map-rightU-sorted ( u ∷ (v ∷ us) ) (>-cons >-sorted-us (>-just u>v))
  = >-cons (map-rightU-sorted (v ∷ us) >-sorted-us)
           (>-just (choice-rr u>v))
  

map-leftU-rightU-sorted : ∀ { l r : RE } { loc : ℕ }
  → ( us : List (U l) )
  → ( vs : List (U r) )
  → >-sorted {l} us   
  → >-sorted {r} vs
  → >-sorted {l + r ` loc } ((List.map LeftU us) ++ (List.map RightU vs))
map-leftU-rightU-sorted               []  vs    >-sorted-l-[] >-sorted-r-vs = map-rightU-sorted vs >-sorted-r-vs
map-leftU-rightU-sorted {l} {r} {loc} us               []        >-sorted-l-us >-sorted-r-[] rewrite (cong (λ x → >-sorted x) (++-identityʳ (List.map (LeftU {l} {r} {loc}) us)))
  = map-leftU-sorted us >-sorted-l-us 
map-leftU-rightU-sorted {l} {r} {loc} (u ∷ [])        (v ∷ vs) >-sorted-l-uus >-sorted-r-vs
  = >-cons (map-rightU-sorted (v ∷ vs) >-sorted-r-vs) (>-just choice-lr)
map-leftU-rightU-sorted {l} {r} {loc} (u ∷ u' ∷ us)   (v ∷ vs) >-sorted-l-uuus >-sorted-r-vvs with >-sorted-l-uuus
... | >-cons >-sorted-uus (>-just  u>u' ) 
  = >-cons (map-leftU-rightU-sorted (u' ∷ us) (v ∷ vs)  >-sorted-uus  >-sorted-r-vvs ) ((>-just (choice-ll u>u' ))) 


          


map-pairU-sorted : ∀ { l r : RE } { loc : ℕ }
  → ( us : List (U l) )
  → ( vs : List (U r) )
  → >-sorted {l} us   
  → >-sorted {r} vs
  -- → >-sorted {l ● r ` loc } (concatMap (λ u₁ → map (PairU u₁) vs) us) -- desugared to foldr _++_ [] for the ease of checking/eye-verifcation 
  → >-sorted {l ● r ` loc } (List.foldr _++_ [] (List.map (λ u₁ → List.map (PairU u₁) vs) us))
map-pairU-sorted  {l} {r} {loc} []         vs >-sorted-[]                         >-sorted-vs  = >-nil
map-pairU-sorted  {l} {r} {loc} (u ∷ [])  vs (>-cons >-nil >-nothing)   >-sorted-vs rewrite (cong (λ x → >-sorted x) (++-identityʳ (List.map (PairU {l} {r} {loc} u) vs)))  = map-pair-u-vs-sorted u vs >-sorted-vs
  where
    map-pair-u-vs-sorted : ( u : U l ) → ( vs : List (U r )) → >-sorted {r} vs → >-sorted { l ● r ` loc } (List.map (PairU u) vs)
    map-pair-u-vs-sorted u []          >-nil = >-nil
    map-pair-u-vs-sorted u ( v ∷ vs ) (>-cons >-sorted-vs v>head-vs) with >-sorted-vs
    ... | >-nil          = >-cons (map-pair-u-vs-sorted u vs >-sorted-vs) >-nothing
    ... | >-cons >-sorted-vs' v'>head-vs' with v>head-vs
    ...            | >-just v>v' = >-cons (map-pair-u-vs-sorted u vs >-sorted-vs) (>-just (seq₂ refl v>v') )

map-pairU-sorted  {l} {r} {loc} (u ∷ u' ∷ us)  vs (>-cons >-sorted-uus (>-just u>u'))  >-sorted-vs
  = combine {u} {u'} {vs} {us} {vs} u>u' (map-pair-u-vs-sorted u vs >-sorted-vs) ind-hyp
  where
    map-pair-u-vs-sorted : ( u : U l ) → ( vs : List (U r )) → >-sorted {r} vs → >-sorted { l ● r ` loc } (List.map (PairU u) vs)
    map-pair-u-vs-sorted u []          >-nil = >-nil
    map-pair-u-vs-sorted u ( v ∷ vs ) (>-cons >-sorted-vs v>head-vs) with >-sorted-vs
    ... | >-nil          = >-cons (map-pair-u-vs-sorted u vs >-sorted-vs) >-nothing 
    ... | >-cons >-sorted-vs' v'>head-vs' with v>head-vs
    ...            | >-just v>v' = >-cons (map-pair-u-vs-sorted u vs >-sorted-vs) (>-just (seq₂ refl v>v') )

    ind-hyp : >-sorted {l ● r ` loc } (concatMap (λ u₁ → List.map (PairU u₁) vs) (u' ∷ us))
    ind-hyp = map-pairU-sorted {l} {r} {loc} (u' ∷ us) vs >-sorted-uus >-sorted-vs

    -- we need to generalize the input vs
    -- `ts` as the duplicated generalized vs, which can be inductively reduced w/o affecting the concatMap (map (PairU u) vs) (u' ∷ us) bit
    -- all the uses of concatMap have been desugared into foldr _++_ [] (map ... )
    combine   :  { u u' : U l } { ts : List (U r) }  { us : List (U l) } { vs : List (U r)  }
              →   l ⊢ u > u' 
              →   >-sorted {l ● r ` loc } (List.map (PairU {l} {r} {loc} u) ts) 
              →   >-sorted {l ● r ` loc } (List.foldr _++_ [] (List.map (λ u₁ → List.map (PairU u₁) vs) (u' ∷ us)))
            -----------------------------------------------------------------------------------
              →   >-sorted {l ● r ` loc } ((List.map (PairU {l} {r} {loc} u) ts)  ++ (List.foldr _++_ [] (List.map (λ u₁ → List.map (PairU u₁) vs) (u' ∷ us))))
    combine {u} {u'} {[]}      {us} {[]}     u>u' >-nil                                                      >-sorted-ys = >-sorted-ys
    combine {u} {u'} {[]}      {us} {vs}     u>u' >-nil                                                      >-sorted-ys = >-sorted-ys
    combine {u} {u'} {t ∷ []} {us} {v ∷ vs} u>u' (>-cons >-sorted-map-pair-u-ts u-t>head-map-pair-u-ts)  >-sorted-ys =
      >-cons >-sorted-ys (>-just (seq₁ u>u')) 
    combine {u} {u'} {t ∷ t' ∷ ts} {us} {vs} u>u' (>-cons >-sorted-map-pair-u-tts u-t>head-map-pair-u-tts) >-sorted-ys =
      >-cons ind-hyp' u-t>head-map-pair-u-tts
      where
        ind-hyp' : >-sorted {l ● r ` loc } ((List.map (PairU {l} {r} {loc} u) (t' ∷ ts))  ++ (List.foldr _++_ [] (List.map (λ u₁ → List.map (PairU u₁) vs) (u' ∷ us))))
        ind-hyp' = combine {u} {u'} {t' ∷ ts} {us} {vs} u>u' >-sorted-map-pair-u-tts >-sorted-ys
    -- the following is impossible to be reached actually, since ts is a subfix of vs
    combine {u} {u'} {t∷[]}   {us}  {[]}    u>u' >-sorted-xs                                                 >-sorted-ys
      rewrite (cong (λ x → >-sorted (List.map (PairU {l} {r} {loc} u) t∷[] ++ x )) (foldr++ys-map-λ_→[]-xs≡ys us []) )
      | (cong (λ x → >-sorted x) ( ++-identityʳ (List.map (PairU {l} {r} {loc} u) t∷[]) ))                                   = >-sorted-xs

-----------------------------------------------------------------------------
-- Sub Lemma 31.1 - 31.4  END
----------------------------------------------------------------------------

```

#### Main proof for Lemma 31

```agda
mkAllEmptyU-sorted : ∀ { r : RE }
  → ( ε∈r : ε∈ r)
  → >-sorted (mkAllEmptyU {r} ε∈r) 
mkAllEmptyU-sorted {$ c ` loc }         = λ()
mkAllEmptyU-sorted {ε}             ε∈ε = >-cons >-nil >-nothing
mkAllEmptyU-sorted {r * nε ` loc}  ε∈* = >-cons >-nil >-nothing 
mkAllEmptyU-sorted {l + r  ` loc}  (ε∈ ε∈l <+ ε∉r) = map-leftU-sorted es ind-hyp
  where
    es : List (U l)
    es = mkAllEmptyU ε∈l 
    ind-hyp : >-sorted  (mkAllEmptyU ε∈l)
    ind-hyp = mkAllEmptyU-sorted {l} ε∈l
mkAllEmptyU-sorted {l + r  ` loc}  (ε∈ ε∉l +> ε∈r) = map-rightU-sorted es ind-hyp
  where
    es : List (U r)
    es = mkAllEmptyU ε∈r 
    ind-hyp : >-sorted  (mkAllEmptyU ε∈r)
    ind-hyp = mkAllEmptyU-sorted {r} ε∈r
mkAllEmptyU-sorted {l + r  ` loc}  (ε∈ ε∈l + ε∈r) =  map-leftU-rightU-sorted l-es r-es l-ind-hyp r-ind-hyp
  where
    r-es : List (U r)
    r-es = mkAllEmptyU ε∈r 
    r-ind-hyp : >-sorted  (mkAllEmptyU ε∈r)
    r-ind-hyp = mkAllEmptyU-sorted {r} ε∈r

    l-es : List (U l)
    l-es = mkAllEmptyU ε∈l
    l-ind-hyp : >-sorted  (mkAllEmptyU ε∈l)
    l-ind-hyp = mkAllEmptyU-sorted {l} ε∈l
mkAllEmptyU-sorted {l ● r ` loc }  (ε∈ ε∈l ● ε∈r ) = map-pairU-sorted l-es r-es l-ind-hyp r-ind-hyp
  where
    r-es : List (U r)
    r-es = mkAllEmptyU ε∈r 
    r-ind-hyp : >-sorted  (mkAllEmptyU ε∈r)
    r-ind-hyp = mkAllEmptyU-sorted {r} ε∈r

    l-es : List (U l)
    l-es = mkAllEmptyU ε∈l
    l-ind-hyp : >-sorted  (mkAllEmptyU ε∈l)
    l-ind-hyp = mkAllEmptyU-sorted {l} ε∈l
```



### Definition 32: >-Strict increasing PDInstance

Let r be a non problematic regular expression.
Let c be a letter.
Let pdi be a PDInstance  w.r.t r and c.
We say pdi is >-inc (strict increasing) iff, 
  1. p is the partial derivative inhabited in pdi, and
  2. inj is the injection function from parse trees of p to parse trees of r.
  3. for all parse trees of p, u₁ and u₂ where p ⊢ u₁ > u₂
  Then r ⊢ inj u₁ > inj u₂ 

```agda

data >-Inc : ∀ { r : RE } { c : Char } →  PDInstance r c  → Set where
  >-inc : ∀ { p r : RE } { c : Char } { inj : U p →  U r }
    { sound-ev : ∀ ( x : U p ) → ( proj₁ ( flat {r} (inj x) ) ≡ c ∷ ( proj₁ (flat {p} x) )) }
    → ( (u₁ : U p) → (u₂ : U p) → p ⊢ u₁ > u₂  → r ⊢ inj u₁ > inj u₂ ) -- strict increasing evidence 
    → >-Inc {r} {c} (pdinstance {p} {r} {c} inj sound-ev)
```

### Lemma 33: all pdinstances from pdU[ r , c ] are >-strict increasing.

Let r be a  non problematic regular expression.
Let c be a letter.
Then for all pdi ∈ pdU[ r , c], pdi is >-strict increasing .


#### Sub Lemma 33.1 - 33.9 : >-Inc is preserved inductively by the pdinstance operations. 

```agda
-----------------------------------------------------------------------------
-- Sub Lemma 33.1 - 33.9  BEGIN
----------------------------------------------------------------------------
>-inc-map-left : ∀ { l r : RE } { loc : ℕ } { c : Char }
    → ( pdis : List (PDInstance l c) )
    → All (>-Inc {l} {c}) pdis
    → All (>-Inc {l + r ` loc } {c}) (List.map pdinstance-left pdis)
>-inc-map-left [] [] = []
>-inc-map-left {l} {r} {loc} {c} ((pdinstance {p} {l} {c}  inj sound-ev) ∷ pdis) (>-inc u₁→u₂→u₁>u₂→inj-u₁>inj-u₂ ∷ pxs)
  = >-inc >-inc-ev   ∷ >-inc-map-left pdis pxs
  where
    >-inc-ev : ∀ (u₁ : U p)
              → (u₂ : U p)
              → p ⊢ u₁ > u₂
              --------------
              → (l + r ` loc) ⊢ LeftU (inj u₁) > LeftU (inj u₂)
    >-inc-ev u₁ u₂ u₁>u₂ =
      let inj-u₁>inj-u₂ = u₁→u₂→u₁>u₂→inj-u₁>inj-u₂ u₁ u₂  u₁>u₂
      in choice-ll inj-u₁>inj-u₂



>-inc-map-right : ∀ { l r : RE } { loc : ℕ } { c : Char }
    → ( pdis : List (PDInstance r c) )
    → All (>-Inc {r} {c}) pdis
    → All (>-Inc {l + r ` loc } {c}) (List.map pdinstance-right pdis)
>-inc-map-right [] [] = []
>-inc-map-right {l} {r} {loc} {c} ((pdinstance {p} {r} {c} inj sound-ev) ∷ pdis) (>-inc  u₁→u₂→u₁>u₂→inj-u₁>inj-u₂ ∷ pxs)
  = >-inc >-inc-ev  ∷ >-inc-map-right pdis pxs
  where
    >-inc-ev : ∀ (u₁ : U p)
              → (u₂ : U p)
              → p ⊢ u₁ > u₂
              --------------
              → (l + r ` loc) ⊢ RightU (inj u₁) > RightU (inj u₂)
    >-inc-ev u₁ u₂ u₁>u₂ =
      let inj-u₁>inj-u₂ = u₁→u₂→u₁>u₂→inj-u₁>inj-u₂ u₁ u₂  u₁>u₂
      in choice-rr inj-u₁>inj-u₂


>-inc-map-fst : ∀ { l r : RE } { loc : ℕ } { c : Char }
               → ( pdis : List (PDInstance l c ) )
               → All (>-Inc {l} {c}) pdis
               → All (>-Inc {l ● r ` loc} {c}) (List.map (pdinstance-fst {l} {r} {loc} {c}) pdis)
>-inc-map-fst [] [] = []
>-inc-map-fst {l} {r} {loc} {c} ((pdinstance {p} {l} {c}  inj sound-ev) ∷ pdis) (>-inc u₁→u₂→u₁>u₂→inj-u₁>inj-u₂ ∷ pxs)
  = (>-inc >-inc-ev)  ∷  >-inc-map-fst pdis pxs
  where
    injFst : U (p ● r ` loc)   → U (l ● r ` loc )
    injFst = mkinjFst inj
    >-inc-ev : ∀ (uv₁ : U ( p ● r ` loc ))
              → (uv₂ : U ( p ● r ` loc ))
              → (p ● r ` loc )  ⊢ uv₁ > uv₂
              ------------------------------------
              → (l ● r ` loc) ⊢ (injFst uv₁) > (injFst uv₂)
    >-inc-ev (PairU u₁ v₁)  (PairU u₂ v₂) (seq₁  u₁>u₂) = 
      let inj-u₁>inj-u₂ = u₁→u₂→u₁>u₂→inj-u₁>inj-u₂ u₁ u₂ u₁>u₂
      in seq₁ inj-u₁>inj-u₂
    >-inc-ev (PairU u₁ v₁)  (PairU u₂ v₂) (seq₂  u₁≡u₂ v₁>v₂ ) = (seq₂ inj-u₁≡inj-u₂ v₁>v₂)  
        where
          inj-u₁≡inj-u₂ : inj u₁ ≡ inj u₂ 
          inj-u₁≡inj-u₂ = cong inj u₁≡u₂

-----------------------------------------------------------------------------------------
-- aux lemma to show that injSnd is >-strict increasing
>-inc-injSnd : ∀ {l r p : RE } { loc : ℕ }
         → ( v : U l )
         → ( inj : U p → U r )         
         → ( u₁ : U p )
         → ( u₂ : U p )
         → r ⊢ inj u₁ > inj u₂
         --------------------------------------------------------------------------
         → ( l ● r ` loc ) ⊢  (mkinjSnd inj v u₁) > (mkinjSnd inj v u₂) 
>-inc-injSnd {l} {r} {p} {loc} v inj u₁ u₂ inj-u₁>inj-u₂ = seq₂ refl inj-u₁>inj-u₂

-- aux lemma to show that mk-snd-pdi is >-strict increasing
>-inc-mk-snd-pdi : ∀ { l r : RE } { loc : ℕ } { c : Char }
   → ( e-flat-[]-e : (∃[ e ] Flat-[] l e)  )
   → ( pdi : PDInstance r c )
   → >-Inc {r} {c} pdi 
   -------------------------------------------------------------------
   → >-Inc (mk-snd-pdi {l} {r} {loc} {c} e-flat-[]-e pdi) 
>-inc-mk-snd-pdi {l} {r} {loc} {c} (e , flat-[] e' proj₁∘flate≡[]) (pdinstance {p} {r} {c} inj s-ev) (>-inc >-inc-inj) =
  >-inc (λ u₁ u₂ u₁>u₂ → ( >-inc-injSnd {l} {r} {p} {loc} e inj u₁ u₂  (>-inc-inj u₁ u₂ u₁>u₂))  )
  where
    -- duplicated from mk-snd-pdi from PartialDerivativeParseTree so that the PDInstance can be inferred
    -- this is needed because p is an existential type `hidden` inside PDInstance r c 
    injSnd :  U p → U (l ● r ` loc)
    injSnd = mkinjSnd {l} {r} {p} {loc} inj e
    injSnd-s-ev =
      (λ u → 
           begin
             proj₁ (flat (PairU {l} {r} {loc} e (inj u)))
           ≡⟨⟩
             (proj₁ (flat e)) ++ (proj₁ (flat (inj u)))
           ≡⟨ cong (λ x → ( x ++  (proj₁ (flat (inj u))))) proj₁∘flate≡[] ⟩  --  e must be an empty; we do have flat v ≡ [] from mkAllEmptyU-sound
             [] ++ (proj₁ (flat (inj u)))
           ≡⟨⟩
             proj₁ (flat (inj u))
           ≡⟨ s-ev u ⟩
             c ∷ (proj₁ (flat u))
           ∎
          )    

-- aux lemma to show that concatMap pdinstance-snd  is >-strict increasing

>-inc-pdinstance-snd : ∀ { l r : RE } { ε∈l : ε∈ l } { loc : ℕ } { c : Char }
  → ( e-flat-[]-e : ∃[ e ] Flat-[] l e )
  → ( pdis : List (PDInstance r c ) )
  → All (>-Inc {r} {c}) pdis
  ---------------------------------------------------------------------------
  → All  (>-Inc {l ● r ` loc} {c}) (List.map  (mk-snd-pdi e-flat-[]-e ) pdis )
>-inc-pdinstance-snd {l} {r} {ε∈l} {loc} {c} e-flat-[]-e []           [] = [] 
>-inc-pdinstance-snd {l} {r} {ε∈l} {loc} {c} e-flat-[]-e (pdi ∷ pdis) (>-inc-pdi ∷ all>-inc-pdis) = (>-inc-mk-snd-pdi e-flat-[]-e pdi >-inc-pdi) ∷ >-inc-pdinstance-snd {l} {r} {ε∈l} {loc} {c} e-flat-[]-e pdis all>-inc-pdis

>-inc-concatmap-pdinstance-snd-sub :  ∀ { l r : RE } { ε∈l : ε∈ l } { loc : ℕ } { c : Char }
  → ( e-flat-[]-es  : List ( ∃[ e ] Flat-[] l e ) )
  → ( pdis : List (PDInstance r c ) )
  → All (>-Inc {r} {c}) pdis
  -----------------------------------------------------------------------------------------------------
  → All (>-Inc {l ● r ` loc} {c}) (concatMap (λ x → pdinstance-snd {l} {r} {loc} {c} x  pdis) e-flat-[]-es)
>-inc-concatmap-pdinstance-snd-sub {l} {r} {ε∈l} {loc} {c} [] _ _ = []
>-inc-concatmap-pdinstance-snd-sub {l} {r} {ε∈l} {loc} {c} ( e-flat-[]-e ∷ e-flat-[]-es ) pdis all>-inc-pdis =
  all-concat  (>-inc-pdinstance-snd {l} {r} {ε∈l} {loc} {c}  e-flat-[]-e  pdis all>-inc-pdis)
              (>-inc-concatmap-pdinstance-snd-sub {l} {r} {ε∈l} {loc} {c} e-flat-[]-es pdis all>-inc-pdis)  


>-inc-concatmap-pdinstance-snd : ∀ { l r : RE } { ε∈l : ε∈ l } { loc : ℕ } { c : Char }
               → ( pdis : List (PDInstance r c ) )
               → All (>-Inc {r} {c}) pdis
               → All (>-Inc {l ● r ` loc} {c}) (concatmap-pdinstance-snd {l} {r} {ε∈l} {loc} {c}  pdis)
>-inc-concatmap-pdinstance-snd {l} {r} {ε∈l} {loc} {c} pdis all>-inc-pdis = >-inc-concatmap-pdinstance-snd-sub  {l} {r} {ε∈l} {loc} {c} (zip-es-flat-[]-es {l} {ε∈l} es flat-[]-es) pdis all>-inc-pdis
  where
    es : List (U l)
    es = mkAllEmptyU {l} ε∈l
    flat-[]-es : All (Flat-[] l) es
    flat-[]-es = mkAllEmptyU-sound {l} ε∈l    

>-inc-map-star : ∀ { r : RE } { ε∉r : ε∉ r } { loc : ℕ } { c : Char }
               → ( pdis : List (PDInstance r c)  )
               → All (>-Inc {r} {c}) pdis
               → All (>-Inc {r * ε∉r ` loc} {c}) (List.map (pdinstance-star {r} {ε∉r} {loc} {c}) pdis)
>-inc-map-star {r} {ε∉r} {loc} {c} [] [] = []
>-inc-map-star {r} {ε∉r} {loc} {c} (pdinstance {p} {r} {c} inj s-ev ∷ pdis) (>-inc >-ev ∷ pxs)  =
  >-inc >-inc-ev ∷ >-inc-map-star pdis pxs
  where
    injList : U (p ● (r * ε∉r ` loc ) ` loc ) → U ( r * ε∉r ` loc )
    injList = mkinjList inj   

    >-inc-ev : ∀ (uv₁ : U ( p ● (r * ε∉r ` loc ) ` loc ))
              → (uv₂ : U ( p ● (r * ε∉r ` loc ) ` loc ))
              → (p ● (r * ε∉r ` loc ) ` loc )  ⊢ uv₁ > uv₂
              ------------------------------------
              → (r * ε∉r ` loc) ⊢ (injList uv₁) > (injList uv₂)
    >-inc-ev (PairU u₁ (ListU vs₁))  (PairU u₂ (ListU vs₂)) (seq₁  u₁>u₂) = 
      let inj-u₁>inj-u₂ = >-ev u₁ u₂ u₁>u₂
      in star-head {r} {loc} {ε∉r} {inj u₁} {inj u₂} {vs₁} {vs₂} inj-u₁>inj-u₂
    >-inc-ev (PairU u₁ (ListU vs₁))  (PairU u₂ (ListU vs₂)) (seq₂  u₁≡u₂ list-vs₁>list-vs₂ ) =
      (star-tail inj-u₁≡inj-u₂ list-vs₁>list-vs₂)  
        where
          inj-u₁≡inj-u₂ : inj u₁ ≡ inj u₂ 
          inj-u₁≡inj-u₂ = cong inj u₁≡u₂

-----------------------------------------------------------------------------
-- Sub Lemma 33.1 - 33.9 END
----------------------------------------------------------------------------

```

#### Main proof for Lemma 33

```agda

pdU->-inc : ∀ { r : RE } { c : Char }
  → All (>-Inc {r} {c}) pdU[ r , c ]

pdUConcat->-inc : ∀ { l r : RE } { ε∈l : ε∈ l } { loc : ℕ } { c : Char }
    → All (>-Inc {l ● r ` loc } {c}) (pdUConcat l r ε∈l loc c)


pdU->-inc {ε} {c} = []
pdU->-inc {$ c ` loc} {c'} with c Char.≟ c'
...  | no ¬c≡c' = []
...  | yes refl =  ( >-inc (λ { EmptyU EmptyU →  λ() } ) ) ∷ []
pdU->-inc {l + r ` loc} {c} = all-concat map-ind-hyp-l map-ind-hyp-r 
  where
    ind-hyp-l : All (>-Inc {l} {c}) pdU[ l , c ]
    ind-hyp-l = pdU->-inc {l} {c}
    
    ind-hyp-r : All (>-Inc {r} {c}) pdU[ r , c ]
    ind-hyp-r = pdU->-inc {r} {c}     

    map-ind-hyp-l : All (>-Inc {l + r ` loc} {c}) (List.map pdinstance-left pdU[ l , c ])
    map-ind-hyp-l = >-inc-map-left pdU[ l , c ]  ind-hyp-l

    map-ind-hyp-r : All (>-Inc {l + r ` loc} {c}) (List.map pdinstance-right pdU[ r , c ])
    map-ind-hyp-r = >-inc-map-right pdU[ r , c ]  ind-hyp-r
pdU->-inc {r * ε∉r ` loc } {c} = all->-inc-map-star
  where
    ind-hyp-r : All (>-Inc {r} {c}) pdU[ r , c ]
    ind-hyp-r = pdU->-inc {r} {c}

    all->-inc-map-star : All (>-Inc {r * ε∉r ` loc} {c}) (List.map (pdinstance-star {r} {ε∉r} {loc} {c})  pdU[ r , c ])
    all->-inc-map-star  = >-inc-map-star pdU[ r , c ] ind-hyp-r


pdU->-inc {l ● r ` loc} {c} with ε∈? l
...                           | no ¬ε∈l = >-inc-map-fst pdU[ l , c ] ind-hyp-l
  where 
    ind-hyp-l : All (>-Inc {l} {c}) pdU[ l , c ]
    ind-hyp-l = pdU->-inc {l} {c}
    
pdU->-inc {l ● r ` loc} {c}  | yes ε∈l = pdUConcat->-inc  

{-# TERMINATING #-}
pdUConcat->-inc {ε} {r} {ε∈ε} {loc} {c} = all-concat all->-inc-pdis-inj-from-l-c all->-inc-concatmap-pdinstance-snd 
  where
    ind-hyp-l : All (>-Inc {ε} {c}) pdU[ ε , c ]
    ind-hyp-l = pdU->-inc {ε} {c}

    all->-inc-pdis-inj-from-l-c : All (>-Inc {ε ● r ` loc} {c}) (List.map (pdinstance-fst {ε} {r} {loc} {c}) pdU[ ε , c ])
    all->-inc-pdis-inj-from-l-c =  >-inc-map-fst pdU[ ε , c ] ind-hyp-l
    
    ind-hyp-r : All (>-Inc {r} {c}) pdU[ r , c ]
    ind-hyp-r = pdU->-inc {r} {c}

    all->-inc-concatmap-pdinstance-snd : All (>-Inc {ε ● r ` loc} {c}) (concatmap-pdinstance-snd {ε} {r} {ε∈ε} {loc} {c} pdU[ r , c ])
    all->-inc-concatmap-pdinstance-snd  = >-inc-concatmap-pdinstance-snd {ε} {r} {ε∈ε} {loc} {c} pdU[ r , c ] ind-hyp-r
pdUConcat->-inc { l * ε∉l ` loc₂ } {r} {ε∈*} {loc} {c} = all-concat all->-inc-pdis-inj-from-l-c all->-inc-concatmap-pdinstance-snd 
  where
    ind-hyp-l : All (>-Inc {l * ε∉l ` loc₂} {c}) pdU[ l * ε∉l ` loc₂ , c ]
    ind-hyp-l = pdU->-inc {l * ε∉l ` loc₂} {c}

    all->-inc-pdis-inj-from-l-c : All (>-Inc {(l * ε∉l ` loc₂) ● r ` loc} {c}) (List.map (pdinstance-fst {l * ε∉l ` loc₂} {r} {loc} {c}) pdU[ l * ε∉l ` loc₂ , c ])
    all->-inc-pdis-inj-from-l-c =  >-inc-map-fst pdU[ l * ε∉l ` loc₂ , c ] ind-hyp-l
    
    ind-hyp-r : All (>-Inc {r} {c}) pdU[ r , c ]
    ind-hyp-r = pdU->-inc {r} {c}

    all->-inc-concatmap-pdinstance-snd : All (>-Inc {(l * ε∉l ` loc₂) ● r ` loc} {c}) (concatmap-pdinstance-snd {l * ε∉l ` loc₂} {r} {ε∈*} {loc} {c}  pdU[ r , c ])
    all->-inc-concatmap-pdinstance-snd  = >-inc-concatmap-pdinstance-snd {l * ε∉l ` loc₂} {r} {ε∈*} {loc} {c}  pdU[ r , c ] ind-hyp-r
pdUConcat->-inc { l ● s ` loc₂ } {r} {ε∈l●s} {loc} {c} = assoc->-inc pdU[ l ● ( s ● r ` loc ) ` loc₂ , c ] ind-hyp
  where
    ind-hyp : All (>-Inc {l ● ( s ● r ` loc)  ` loc₂} {c}) pdU[ l ● ( s ● r ` loc ) ` loc₂ , c ]
    ind-hyp  = pdU->-inc {l ● ( s ● r ` loc)  ` loc₂} {c} 

    assoc->-inc : (pdis : List (PDInstance (l ● ( s ● r ` loc) ` loc₂)  c) )
       → All (>-Inc { l ● ( s ● r ` loc) ` loc₂} {c})  pdis
       → All (>-Inc {( l ●  s ` loc₂) ● r ` loc} {c}) (List.map pdinstance-assoc pdis)
    assoc->-inc [] [] = []
    assoc->-inc (pdi ∷ pdis) ((>-inc {p} { l ● ( s ● r ` loc) ` loc₂} {c} {inj} {s-ev}  u₁→u₂→u₁>u₂→inj-u₁>inj-u₂) ∷ all>-inc-pdis) =
      (>-inc ev->) ∷ (assoc->-inc pdis all>-inc-pdis)
      where
        ev-> : (u₁ : U p) → (u₂ : U p) → p ⊢ u₁ > u₂
             → ((l ● s ` loc₂) ● r ` loc) ⊢ (mkinjAssoc inj) u₁ > (mkinjAssoc inj) u₂
        ev-> u₁ u₂ u₁>u₂ with inj u₁                  | inj u₂                   | u₁→u₂→u₁>u₂→inj-u₁>inj-u₂ u₁ u₂ u₁>u₂ 
        ...                | PairU v₁ (PairU v₂ v₃)   | PairU v₄ (PairU v₅ v₆)   | seq₁ v₁>v₄                  = seq₁ (seq₁ v₁>v₄)
        ...                | PairU v₁ (PairU v₂ v₃)   | PairU v₄ (PairU v₅ v₆)   | seq₂ refl (seq₁ v₂>v₅)      = seq₁ (seq₂ refl v₂>v₅)
        ...                | PairU v₁ (PairU v₂ v₃)   | PairU v₄ (PairU v₅ v₆)   | seq₂ refl (seq₂ refl v₃>v₆) = seq₂ refl v₃>v₆

pdUConcat->-inc { l + s ` loc₂ } {r} {ε∈l+s} {loc} {c} = 
  dist->-inc ((List.map pdinstance-left pdU[ l ● r ` loc  , c ]) ++ (List.map pdinstance-right pdU[ s ● r ` loc , c ]))  (concat pdU[ l ● r ` loc  , c ]  pdU[ s ● r ` loc , c ] map-ind-hyp-l map-ind-hyp-r)
  where
    ind-hyp-l : All (>-Inc {l ● r ` loc } {c}) pdU[ l ● r ` loc , c ]
    ind-hyp-l = pdU->-inc {l ● r ` loc } {c}
    
    ind-hyp-r : All (>-Inc {s ● r ` loc } {c}) pdU[ s ● r ` loc , c ]
    ind-hyp-r = pdU->-inc {s ● r ` loc } {c}     

    map-ind-hyp-l : All (>-Inc {(l ● r ` loc) + (s ● r ` loc ) ` loc₂} {c}) (List.map pdinstance-left pdU[ l ● r ` loc  , c ])
    map-ind-hyp-l = >-inc-map-left pdU[ l ● r ` loc , c ]  ind-hyp-l

    map-ind-hyp-r : All (>-Inc {(l ● r ` loc) + (s ● r ` loc ) ` loc₂} {c}) (List.map pdinstance-right pdU[ s ● r ` loc , c ])
    map-ind-hyp-r = >-inc-map-right pdU[ s ● r ` loc  , c ]  ind-hyp-r


    concat : ( pdis : List (PDInstance (l ● r ` loc)  c ))
      → ( pdis' : List (PDInstance (s ● r ` loc ) c))
      →  All (>-Inc {(l ● r ` loc) + (s ● r ` loc ) ` loc₂} {c}) (List.map pdinstance-left pdis)
      →  All (>-Inc {(l ● r ` loc) + (s ● r ` loc ) ` loc₂} {c}) (List.map pdinstance-right pdis')  
      →  All (>-Inc {(l ● r ` loc) + (s ● r ` loc ) ` loc₂} {c}) ( (List.map pdinstance-left pdis) ++ (List.map pdinstance-right pdis') )
    concat pdis pdis' all->-inc-pdis all->-inc-pdis' = all-concat all->-inc-pdis all->-inc-pdis'

    dist->-inc : (pdis : List (PDInstance ((l ● r ` loc) + (s ● r ` loc ) ` loc₂) c))
       → All (>-Inc {(l ● r ` loc) + (s ● r ` loc ) ` loc₂} {c}) pdis
       → All (>-Inc {( l + s ` loc₂ ) ● r ` loc  }  {c}) (List.map pdinstance-dist pdis)
    dist->-inc [] [] = []
    dist->-inc (pdi ∷ pdis) ((>-inc {p} {(l ● r ` loc) + (s ● r ` loc ) ` loc₂} {c} {inj} {s-ev} u₁→u₂→u₁>u₂→inj-u₁>inj-u₂) ∷ all>-inc-pdis) =
      (>-inc ev->) ∷ (dist->-inc pdis all>-inc-pdis)
      where
        ev-> : (u₁ : U p) → (u₂ : U p) → p ⊢ u₁ > u₂
          → ((l + s ` loc₂) ● r ` loc) ⊢ (mkinjDist inj) u₁ > (mkinjDist inj) u₂
        ev->  u₁ u₂ u₁>u₂ with inj u₁            | inj u₂                | u₁→u₂→u₁>u₂→inj-u₁>inj-u₂ u₁ u₂ u₁>u₂ 
        ...              | LeftU (PairU v₁ v₁')  | LeftU (PairU v₂ v₂')  | choice-ll (seq₁ v₁>v₂) = seq₁ (choice-ll v₁>v₂)
        ...              | LeftU (PairU v₁ v₁')  | LeftU (PairU v₂ v₂')  | choice-ll (seq₂ v₁≡v₂ v₁'>v₂') = seq₂ (cong LeftU v₁≡v₂) v₁'>v₂'
        ...              | RightU (PairU v₁ v₁') | RightU (PairU v₂ v₂') | choice-rr (seq₁ v₁>v₂) = seq₁ (choice-rr v₁>v₂)
        ...              | RightU (PairU v₁ v₁') | RightU (PairU v₂ v₂') | choice-rr (seq₂ v₁≡v₂ v₁'>v₂') = seq₂ (cong RightU v₁≡v₂) v₁'>v₂'
        ...              | LeftU (PairU v₁ v₁') | RightU (PairU v₂ v₂') | choice-lr  = seq₁ choice-lr 

        
       
```



### Definition 34: >-Strict increasing PDInstance*

Let r be a non problematic regular expression.
Let w be a word.
Let pdi be a PDInstance* w.r.t r and w.
We say pdi is >-inc (strict increasing) iff,
  1. p be the partial derivative descendant inhabited in pdi, and
  2. inj is the injection function from parse tress of p to parse tress of r.
  3. for all parse trees p, u₁ and u₂ where p ⊢ u₁ > u₂
  Then r ⊢ inj u₁ > inj u₂


```agda

data *>-Inc : ∀ { r : RE } { w : List Char } → PDInstance* r w → Set where
  *>-inc : ∀ { p r : RE } { w : List Char } { inj : U p → U r }
    { sound-ev : ∀ ( x : U p ) → (proj₁ ( flat {r} (inj x ) ) ≡ w ++ (proj₁ (flat {p} x))) }
    → ( (u₁ : U p) → (u₂ : U p ) → p ⊢ u₁ > u₂ → r ⊢ inj u₁ > inj u₂ ) -- strict increasing evidence
    → *>-Inc {r} {w} (pdinstance* {p} {r} {w} inj sound-ev) 

```


### Lemma 35 : all pdinstance*'s from pdUMany[ r , w ] are >-strict increasing .

Let r be a non problematic regular expression.
Let w be a word.
Then for all pdi ∈ pdUMany[ r , w ], pdi is >-strict increasing. 


#### Sub Lemma 35.1 - 35.3 : *>-Inc is preserved inductively over pdinstance*'s operations

```agda
-----------------------------------------------------------------------------
-- Sub Lemma 35.1 - 35.3 BEGIN 
----------------------------------------------------------------------------
compose-pdi-with-*>-inc : { r d : RE } { pref : List Char } { c : Char }
                   → ( d→r : U d → U r )
                   → ( s-ev-d→r : ∀ ( v : U d ) → ( proj₁ ( flat {r} (d→r v) ) ≡ pref ++ ( proj₁ (flat {d} v) )) )
                   → (pdi : PDInstance d c)
                   → >-Inc pdi
                   → ( (x₁ : U d) → (x₂ : U d) → (d ⊢ x₁ > x₂) → r ⊢ d→r x₁ > d→r x₂ )
                   ---------------------------------------------------------------
                   → *>-Inc (compose-pdi-with {r} {d} {pref} {c} d→r s-ev-d→r pdi)
compose-pdi-with-*>-inc {r} {d} {pref} {c} d→r s-ev-d→r pdi@(pdinstance {p} {d} {c}  p→d s-ev-p→d) (>-inc u₁→u₂→u₁>u₂→pd-u₁>pd-u₂ ) x₁→x₂→x₁>x₂→dr-x₁>dr-x₂ = *>-inc ev-*>-inc 
  where
    ev-*>-inc : (v₁ v₂ : U p)
      → p ⊢ v₁ > v₂
      → r ⊢ d→r (p→d v₁) > d→r (p→d v₂)
    ev-*>-inc v₁ v₂ v₁>v₂ = x₁→x₂→x₁>x₂→dr-x₁>dr-x₂ (p→d v₁) (p→d v₂) (u₁→u₂→u₁>u₂→pd-u₁>pd-u₂ v₁ v₂ v₁>v₂)   


advance-pdi*-with-c-*>-inc : ∀ { r : RE } { pref : List Char } { c : Char}
  → (pdi : PDInstance* r pref)
  → *>-Inc pdi
  ----------------------------------------------------------
  → All *>-Inc (advance-pdi*-with-c {r} {pref} {c} pdi)
advance-pdi*-with-c-*>-inc {r} {pref} {c} pdi@(pdinstance* {d} {r} {pref} d→r s-ev-d→r) (*>-inc u₁→u₂→u₁>u₂→dr-u₁>dr-u₂)= go pdU[ d , c ]  (pdU->-inc {d} {c}) 
  where
    go : ( pdis : List (PDInstance d c) )
       → All >-Inc pdis
       → All *>-Inc (List.map (compose-pdi-with {r} {d} {pref} {c} d→r s-ev-d→r) pdis)
    go [] [] = []
    go (pdi ∷ pdis) (pdi->-inc ∷ all->-inc-pdis) = ( compose-pdi-with-*>-inc {r} {d} {pref} {c} d→r s-ev-d→r pdi pdi->-inc u₁→u₂→u₁>u₂→dr-u₁>dr-u₂ ) ∷ go pdis all->-inc-pdis 


concatmap-advance-pdi*-with-c-*>inc : ∀ { r : RE } { pref : List Char } { c : Char}
  → (pdis : List (PDInstance* r pref) )
  → All *>-Inc pdis
  ----------------------------------------------------------
  → All *>-Inc (concatMap (advance-pdi*-with-c {r} {pref} {c}) pdis)
concatmap-advance-pdi*-with-c-*>inc {r} {pref} {c} [] [] = []
concatmap-advance-pdi*-with-c-*>inc {r} {pref} {c} (pdi ∷ pdis) (pdi-*>-inc ∷ all-*>-inc-pdis) = all-concat all-*>-inc-advance-pdi*-with-c-pdi ind-hyp 

  where
    all-*>-inc-advance-pdi*-with-c-pdi : All *>-Inc (advance-pdi*-with-c {r} {pref} {c} pdi)
    all-*>-inc-advance-pdi*-with-c-pdi = advance-pdi*-with-c-*>-inc pdi pdi-*>-inc

    ind-hyp : All *>-Inc (concatMap (advance-pdi*-with-c {r} {pref} {c}) pdis)
    ind-hyp = concatmap-advance-pdi*-with-c-*>inc {r} {pref} {c} pdis all-*>-inc-pdis

-----------------------------------------------------------------------------
-- Sub Lemma 35.1 - 35.3 END
----------------------------------------------------------------------------

```

#### Main proof for Lemma 35

```agda

pdUMany-aux-*>-inc : ∀ { r : RE } { pref : List Char} 
  → (suff : List Char )
  → (pdis : List (PDInstance* r pref))
  → All *>-Inc pdis
  ----------------------------------------------------
  → All *>-Inc (pdUMany-aux suff pdis)
pdUMany-aux-*>-inc {r} {pref} [] pdis all-*>-inc-pdis rewrite (++-identityʳ pref) = all-*>-inc-pdis
pdUMany-aux-*>-inc {r} {pref} ( c ∷ cs) pdis all-*>-inc-pdis = pdUMany-aux-*>-inc {r} {pref ∷ʳ c} cs (concatMap (advance-pdi*-with-c {r} {pref} {c}) pdis) concatmap-advance-pdi*-with-c-pdis-all-*>inc

  where
    concatmap-advance-pdi*-with-c-pdis-all-*>inc : All *>-Inc (concatMap (advance-pdi*-with-c {r} {pref} {c}) pdis)
    concatmap-advance-pdi*-with-c-pdis-all-*>inc = concatmap-advance-pdi*-with-c-*>inc pdis all-*>-inc-pdis 



pdUMany-*>-inc : ∀ { r : RE } { w : List Char }
  → All (*>-Inc {r} {w}) pdUMany[ r  , w ]
pdUMany-*>-inc {r} {w} = pdUMany-aux-*>-inc w  [  ( pdinstance* {r} {r} {[]} (λ u → u) (λ u → refl) ) ] (*>-inc ev-*>-inc  ∷ [] )
  where
    ev-*>-inc : (u₁ : U r)
      → (u₂ : U r)
      → r ⊢ u₁ > u₂
      --------------------------------
      → r ⊢ (λ u → u) u₁ > (λ u → u) u₂ 
    ev-*>-inc u₁ u₂ u₁>u₂ = u₁>u₂ 
  
```
