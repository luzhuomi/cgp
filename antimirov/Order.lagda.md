```agda
{-# OPTIONS --rewriting #-}
module cgp.antimirov.Order where

import cgp.RE as RE
open RE using (RE; ε ; $_`_ ; _●_`_ ; _+_`_ ; _*_`_ ; ε∉ ; ε∈  ; ε∈_+_  ; ε∈_<+_ ; ε∈_+>_ ; ε∈_●_ ; ε∈*  ; ε∈ε ; ε∉r→¬ε∈r ; ε∉fst ; ε∉snd ; ε∉$ ; ε∉_+_ ; ε∉? ; ε∈? )


import cgp.Utils as Utils
open Utils using (foldr++ys-map-λ_→[]-xs≡ys ; all-concat )


import cgp.Word as Word
open Word using ( _∈⟦_⟧ ; ε ;  $_ ; _+L_ ; _+R_ ; _●_⧺_ ; _* )


import cgp.ParseTree as ParseTree
open ParseTree using ( U; EmptyU ; LetterU ;  LeftU ; RightU ; PairU ; ListU ; flat ; unflat ; unflat∘proj₂∘flat ; flat∘unflat ) 

import cgp.empty.AllEmptyParseTree as AllEmptyParseTree
open AllEmptyParseTree using ( mkAllEmptyU ; mkAllEmptyU-sound ; Flat-[] ; flat-[] )


import cgp.antimirov.PartialDerivative as PartialDerivative
open PartialDerivative using ( pdU[_,_] ; PDInstance ; pdinstance ; pdinstance-left ; pdinstance-right;  pdinstance-fst ; mkinjFst ;  pdinstance-snd ; zip-es-flat-[]-es;   mk-snd-pdi ; mkinjSnd ; concatmap-pdinstance-snd; pdinstance-star ; mkinjList ; pdUMany[_,_];  PDInstance* ; pdinstance*  ) 


import Data.Char as Char
open Char using (Char )

import Data.Nat as Nat
open Nat using ( ℕ ; suc ; zero )

import Data.Maybe as Maybe
open Maybe using (Maybe ; just ; nothing )

import Data.List as List
open List using (List ; _∷_ ; [] ; _++_ ; [_]; map; head; concatMap ; _∷ʳ_ ; length )

import Data.List.Properties
open Data.List.Properties using (  ++-identityʳ ; ++-identityˡ ; ∷ʳ-++ ; ++-cancelˡ )


import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; refl; trans; sym; cong; cong-app; subst)
open Eq.≡-Reasoning using (begin_; step-≡;  step-≡-∣;  step-≡-⟩; _∎)


import Data.Product as Product
open Product using (Σ; _,_; ∃; Σ-syntax; ∃-syntax; _×_ )
open Σ using (proj₁ ; proj₂)

import Data.List.Relation.Unary.All as All
open All using (All ; _∷_ ; [] ; map)

import Relation.Nullary as Nullary 
import Relation.Nullary.Negation using (contradiction; contraposition)
open Nullary using (¬_)

import Relation.Nullary.Decidable as Decidable
open Decidable using
  ( Dec; yes; no; ⌊_⌋; True; toWitness; fromWitness; _×-dec_; _⊎-dec_; ¬?)

open import Function using (_∘_ ; flip)

```


Next we would like to show that the list of parse trees generated by `parseAll`
is sorted according to the antimriov matching policy.


For instance in [Example ParseAll](../pderiv/PartialDerivativeParseTree.lagda.md#example-parseall),
we find that the two output parse trees are sorted according to the greedy matching
policy, as the word captured by the left sub tree in
`PairU (ListU [LetterU ’a’]) (ListU [])`

is longer than the one captured in

`PairU (ListU [], ListU [LetteU ’a’])`.


TODO: the following definition need to be fixed. It is Antimirov's ordering not Greedy ordering


### Definition 27 : Antimirov ordering among parse trees

Let r be a non problematic regular expression

Let v₁ v₂ be parse trees of r.
We define the ordering among v1 and v2 as follows


Note: r ⊢ v₁ > v₂ means v₁ is greater than v₂ in Antimirov's ordering. 


seq₁ cases:
  only compare v₁ and v₁' by tag when their both empty and non empty. What about length |v₁'| > length |v₁| ?


r = (a* + a*) ● a*

w = a a

u1 = Pair (L [a]) [a]
u2 = Pair (R [a]) [a]

r ⊢ u1 > u2 for both anti and greedy order


what about?

u3 = Pair (L []) [a,a]
u4 = Pair (R [a,a]) []

if it is greedy u3 > u4

if it is anti u4 > u3


what about? 


u5 = Pair (L [a]) [a]
u6 = Pair (R [a,a]) []


if it is greedy u5 > u6

if it is anti u5 > u6, but why? clearly in this not right non greedy.  if it is right non greedy, u6 > u5!!


```agda
infix 4 _⊢_>_

data _⊢_>_ : ∀ ( r : RE ) → U r → U r → Set where
  -- still not quite right, u5 and u6 case 
  seq₁w-≡ : ∀ { l r : RE } { loc : ℕ } { v₁ v₁'  : U l } { v₂ v₂' : U r }
    →  proj₁ (flat v₁)  ≡  proj₁ (flat v₁')
    → l ⊢ v₁ > v₁' 
    ------------------------------------------------------------------
    →  ( l ● r ` loc ) ⊢ (PairU v₁ v₂) > (PairU v₁' v₂')
    
  seq₁pref : ∀ { l r : RE } { loc : ℕ } { v₁ v₁'  : U l } { v₂ v₂' : U r } -- TODO: Not sure whether it is correct. Search for the TODO below
    →  ∃[ c ] ∃[ cs ] ( proj₁ (flat v₁)  ≡ proj₁ (flat v₂) ++ (c ∷ cs) )
    →  proj₁ (flat v₁') ≡ []     
    ------------------------------------------------------------------
    →  ( l ● r ` loc ) ⊢ (PairU v₁ v₂) > (PairU v₁' v₂')
    
  seq₂ : ∀ { l r : RE } { loc : ℕ } { v₁ v₁'  : U l } { v₂ v₂' : U r }
    → v₁ ≡ v₁'
    → r ⊢ v₂ > v₂'
    -------------------------------------------------------------------
    →  ( l ● r ` loc) ⊢ (PairU v₁ v₂) > (PairU v₁' v₂')

{-
  seq₁bothempty : ∀ { l r : RE } { loc : ℕ } { v₁ v₁'  : U l } { v₂ v₂' : U r }
    →  proj₁ (flat v₁)  ≡ [] 
    →  proj₁ (flat v₁') ≡ [] 
    → l ⊢ v₁ > v₁' 
    ------------------------------------------------------------------
    →  ( l ● r ` loc ) ⊢ (PairU v₁ v₂) > (PairU v₁' v₂')
    
  seq₁oneempty : ∀ { l r : RE } { loc : ℕ } { v₁ v₁'  : U l } { v₂ v₂' : U r } -- TODO: Not sure whether it is correct. Search for the TODO below
    →  ( ¬ ( proj₁ (flat v₁)  ≡ [] ))
    →  proj₁ (flat v₁') ≡ []     
    ------------------------------------------------------------------
    →  ( l ● r ` loc ) ⊢ (PairU v₁ v₂) > (PairU v₁' v₂')
    
  seq₁notempty : ∀ { l r : RE } { loc : ℕ } { v₁ v₁'  : U l } { v₂ v₂' : U r }
    → ¬ ( proj₁ (flat v₁) ≡ [] )
    → ¬ ( proj₁ (flat v₁') ≡ [] )    
    → l ⊢ v₁ > v₁' 
    ------------------------------------------------------------------
    →  ( l ● r ` loc) ⊢ (PairU v₁ v₂) > (PairU v₁' v₂')    
  seq₂ : ∀ { l r : RE } { loc : ℕ } { v₁ v₁'  : U l } { v₂ v₂' : U r }
    → v₁ ≡ v₁'
    → r ⊢ v₂ > v₂'
    -------------------------------------------------------------------
    →  ( l ● r ` loc) ⊢ (PairU v₁ v₂) > (PairU v₁' v₂')
  -} 
  {- right not greedy -- not working 
  seq₁ : ∀ { l r : RE } { loc : ℕ } { v₁ v₁' : U l } { v₂ v₂' : U r }
    → v₂ ≡ v₂'
    → l ⊢ v₁ > v₁'
    -------------------------------------------------------------------
    →  ( l ● r ` loc) ⊢ (PairU v₁ v₂) > (PairU v₁' v₂')

  seq₂ : ∀ { l r : RE } { loc : ℕ } { v₁ v₁' : U l } { v₂ v₂' : U r }
    → r ⊢ v₂' > v₂  -- right not greedy 
    -------------------------------------------------------------------
    →  ( l ● r ` loc) ⊢ (PairU v₁ v₂) > (PairU v₁' v₂')
  -}
  choice-lr : ∀ { l r : RE } { loc : ℕ } { v₁ : U l } { v₂ : U r }
    → ( l + r ` loc ) ⊢ (LeftU v₁) > (RightU v₂)


  choice-ll : ∀ { l r : RE } { loc : ℕ } { v₁ v₁'  : U l } 
    →  l ⊢ v₁ >  v₁'
    -------------------------------------------------------------------
    → ( l + r ` loc ) ⊢ (LeftU v₁) > (LeftU v₁')


  choice-rr : ∀ { l r : RE } { loc : ℕ } { v₂ v₂'  : U r } 
    →  r ⊢ v₂ >  v₂'
    -------------------------------------------------------------------
    → ( l + r ` loc ) ⊢ (RightU v₂) > (RightU v₂')


  star-cons-nil : ∀ { r : RE } { loc : ℕ } { nε : ε∉ r } { v : U r } { vs : List (U r) }
    → ( r * nε ` loc ) ⊢ (ListU (v ∷ vs)) > ( ListU [] )
    

  star-head : ∀ { r : RE } { loc : ℕ } { nε : ε∉ r } { v₁ v₂ : U r } { vs₁ vs₂ : List (U r) }
    → r ⊢ v₁ > v₂
    ----------------------------------------------------------------------
    → ( r * nε ` loc ) ⊢ (ListU (v₁ ∷ vs₁)) > (ListU (v₂ ∷ vs₂))


  star-tail : ∀ { r : RE } { loc : ℕ } { nε : ε∉ r } { v₁ v₂ : U r } { vs₁ vs₂ : List (U r) }
    → v₁ ≡ v₂
    → ( r * nε ` loc ) ⊢ (ListU vs₁) > (ListU vs₂)
    ----------------------------------------------------------------------
    → ( r * nε ` loc ) ⊢ (ListU (v₁ ∷ vs₁)) > (ListU (v₂ ∷ vs₂))


```

> Is the above relation reflexive? No, hence it is not even a preorder.


### Example Antimirov Order

For exapmle we find that

```agda
module ExampleAntimirov where
  
  a*●a* : RE
  a*●a* = ( ( $ 'a' ` 1 ) * ε∉$ ` 2 ) ● ( ( $ 'a' ` 3 ) * ε∉$ ` 4 ) ` 5

  t1 : U a*●a*
  t1 = PairU (ListU (LetterU 'a' ∷ [])) (ListU [])

  t2 : U a*●a*
  t2 = PairU (ListU []) (ListU (LetterU 'a' ∷ []))

  {-
  ev1 : ¬ ((proj₁ (flat {(( $ 'a' ` 1 ) * ε∉$ ` 2)} (ListU (LetterU 'a' ∷ [])))) ≡ [])
  ev1 = λ()

  ev2 : (proj₁ (flat {(( $ 'a' ` 1 ) * ε∉$ ` 2)} (ListU []))) ≡ []
  ev2 = refl
  -}
    

  t1>t2 : a*●a* ⊢  t1 > t2 
  t1>t2 = seq₁pref ( 'a' , ( [] , refl )) 
```


### Definition 28: >-sortedness 


```agda
data >-maybe : ∀ { r : RE } ( u : U r ) → ( mv : Maybe (U r) ) → Set where 
  >-nothing : ∀ { r : RE }
    → ( u : U r)
    ------------------------ 
    → >-maybe {r} u nothing

  >-just : ∀ { r : RE }
    → ( u : U r )
    → ( v : U r )
    → r ⊢ u > v 
    ---------------------------
    → >-maybe {r} u (just v)


data >-sorted : ∀ { r : RE } ( us : List (U r) ) → Set where
  >-nil : ∀ { r : RE } → >-sorted {r} []
  >-cons : ∀ { r : RE }
    → ( u : U r )
    → ( us : List (U r) )
    → >-sorted {r} us
    → >-maybe {r} u (head us)
    --------------------------
    → >-sorted {r} ( u ∷ us  )
```



### Lemma 29: Parse trees generated by mkAllEmptyU is greedily sorted. (Lemma 20 from [2])

Let r be a non problematic regular expression, such that ε∈r.
Then (mkAllEmptyU ε∈r) is greedily sorted. 



```agda
-- aux lemma
map-leftU-sorted : ∀ { l r : RE } { loc : ℕ }
  → ( us : List (U l) )
  → >-sorted {l} us
  → >-sorted {l + r ` loc } (List.map LeftU us)
map-leftU-sorted []          >-nil = >-nil
map-leftU-sorted ( u ∷ [] ) (>-cons _ _  >-nil (>-nothing u) )
  = >-cons (LeftU u) (List.map LeftU []) >-nil (>-nothing (LeftU u))
map-leftU-sorted ( u ∷ (v ∷ us) ) (>-cons _ _  >-sorted-us (>-just u v u>v))
  = >-cons (LeftU u)
           (List.map LeftU (v ∷ us))
           (map-leftU-sorted (v ∷ us) >-sorted-us)
           (>-just (LeftU u) (LeftU v) (choice-ll u>v))


map-rightU-sorted : ∀ { l r : RE } { loc : ℕ }
  → ( us : List (U r) )
  → >-sorted {r} us
  → >-sorted {l + r ` loc } (List.map RightU us)
map-rightU-sorted []          >-nil = >-nil
map-rightU-sorted ( u ∷ [] ) (>-cons _ _  >-nil (>-nothing u) )
  = >-cons (RightU u) (List.map RightU []) >-nil (>-nothing (RightU u))
map-rightU-sorted ( u ∷ (v ∷ us) ) (>-cons _ _  >-sorted-us (>-just u v u>v))
  = >-cons (RightU u)
           (List.map RightU (v ∷ us))
           (map-rightU-sorted (v ∷ us) >-sorted-us)
           (>-just (RightU u) (RightU v) (choice-rr u>v))
  

map-leftU-rightU-sorted : ∀ { l r : RE } { loc : ℕ }
  → ( us : List (U l) )
  → ( vs : List (U r) )
  → >-sorted {l} us   
  → >-sorted {r} vs
  → >-sorted {l + r ` loc } ((List.map LeftU us) ++ (List.map RightU vs))
map-leftU-rightU-sorted               []  vs    >-sorted-l-[] >-sorted-r-vs = map-rightU-sorted vs >-sorted-r-vs
map-leftU-rightU-sorted {l} {r} {loc} us               []        >-sorted-l-us >-sorted-r-[] rewrite (cong (λ x → >-sorted x) (++-identityʳ (List.map (LeftU {l} {r} {loc}) us)))
  = map-leftU-sorted us >-sorted-l-us 
map-leftU-rightU-sorted {l} {r} {loc} (u ∷ [])        (v ∷ vs) >-sorted-l-uus >-sorted-r-vs
  = >-cons (LeftU u) (List.map LeftU [] ++ List.map RightU (v ∷ vs)) (map-rightU-sorted (v ∷ vs) >-sorted-r-vs) (>-just (LeftU u) (RightU v) choice-lr)
map-leftU-rightU-sorted {l} {r} {loc} (u ∷ u' ∷ us)   (v ∷ vs) >-sorted-l-uuus >-sorted-r-vvs with >-sorted-l-uuus
... | >-cons {l} _ _ >-sorted-uus (>-just u₁ u₁' u>u' ) 
  = >-cons (LeftU u) (List.map LeftU (u' ∷ us) ++ List.map RightU (v ∷ vs)) (map-leftU-rightU-sorted (u' ∷ us) (v ∷ vs)  >-sorted-uus  >-sorted-r-vvs ) ((>-just (LeftU u₁) (LeftU u₁') (choice-ll u>u' ))) 


          


map-pairU-empty-sorted : ∀ { l r : RE } { loc : ℕ }
  → ( us : List (U l) )
  → ( vs : List (U r) )
  → All (Flat-[] l) us
  → >-sorted {l} us   
  → >-sorted {r} vs
  → >-sorted {l ● r ` loc } (List.foldr _++_ [] (List.map (λ u₁ → List.map (PairU u₁) vs) us))
map-pairU-empty-sorted  {l} {r} {loc} []        vs []             >-sorted-[]                         >-sorted-vs  = >-nil
map-pairU-empty-sorted  {l} {r} {loc} (u ∷ [])  vs all-flat-[]-u  (>-cons _ _ >-nil (>-nothing u) )   >-sorted-vs rewrite (cong (λ x → >-sorted x) (++-identityʳ (List.map (PairU {l} {r} {loc} u) vs)))  = map-pair-u-vs-sorted u vs >-sorted-vs
  where
    map-pair-u-vs-sorted : ( u : U l ) → ( vs : List (U r )) → >-sorted {r} vs → >-sorted { l ● r ` loc } (List.map (PairU u) vs)
    map-pair-u-vs-sorted u []          >-nil = >-nil
    map-pair-u-vs-sorted u ( v ∷ vs ) (>-cons v vs >-sorted-vs v>head-vs) with >-sorted-vs
    ... | >-nil          = >-cons (PairU u v) (List.map (PairU u) vs) (map-pair-u-vs-sorted u vs >-sorted-vs) (>-nothing (PairU u v)  )
    ... | >-cons v' vs' >-sorted-vs' v'>head-vs' with v>head-vs
    ...            | >-just v v' v>v' = >-cons (PairU u v) (List.map (PairU u) vs) (map-pair-u-vs-sorted u vs >-sorted-vs) (>-just (PairU u v) (PairU u v') (seq₂ refl v>v') )

map-pairU-empty-sorted  {l} {r} {loc} (u ∷ u' ∷ us)  vs (flat-[] u flat-u≡[] ∷ flat-[] u' flat-u'≡[] ∷ all-flat-[]-us) (>-cons _ _ >-sorted-uus (>-just u u' u>u'))  >-sorted-vs
  = combine {u} {u'} {vs} {us} {vs} u>u' (flat-[] u flat-u≡[]) (flat-[] u' flat-u'≡[]) (map-pair-u-vs-sorted u vs >-sorted-vs) ind-hyp
  where
    map-pair-u-vs-sorted : ( u : U l ) → ( vs : List (U r )) → >-sorted {r} vs → >-sorted { l ● r ` loc } (List.map (PairU u) vs)
    map-pair-u-vs-sorted u []          >-nil = >-nil
    map-pair-u-vs-sorted u ( v ∷ vs ) (>-cons v vs >-sorted-vs v>head-vs) with >-sorted-vs
    ... | >-nil          = >-cons (PairU u v) (List.map (PairU u) vs) (map-pair-u-vs-sorted u vs >-sorted-vs) (>-nothing (PairU u v)  )
    ... | >-cons v' vs' >-sorted-vs' v'>head-vs' with v>head-vs
    ...            | >-just v v' v>v' = >-cons (PairU u v) (List.map (PairU u) vs) (map-pair-u-vs-sorted u vs >-sorted-vs) (>-just (PairU u v) (PairU u v') (seq₂ refl v>v') )

    
    ind-hyp : >-sorted {l ● r ` loc } (concatMap (λ u₁ → List.map (PairU u₁) vs) (u' ∷ us))
    ind-hyp = map-pairU-empty-sorted {l} {r} {loc} (u' ∷ us) vs (flat-[] u' flat-u'≡[] ∷ all-flat-[]-us) >-sorted-uus >-sorted-vs

    -- we need to generalize the input vs
    -- `ts` as the duplicated generalized vs, which can be inductively reduced w/o affecting the concatMap (map (PairU u) vs) (u' ∷ us) bit
    -- all the uses of concatMap have been desugared into foldr _++_ [] (map ... )
    combine   :  { u u' : U l } { ts : List (U r) }  { us : List (U l) } { vs : List (U r)  }
              →   l ⊢ u > u'
              →   Flat-[] l u
              →   Flat-[] l u' 
              →   >-sorted {l ● r ` loc } (List.map (PairU {l} {r} {loc} u) ts) 
              →   >-sorted {l ● r ` loc } (List.foldr _++_ [] (List.map (λ u₁ → List.map (PairU u₁) vs) (u' ∷ us)))
            -----------------------------------------------------------------------------------
              →   >-sorted {l ● r ` loc } ((List.map (PairU {l} {r} {loc} u) ts)  ++ (List.foldr _++_ [] (List.map (λ u₁ → List.map (PairU u₁) vs) (u' ∷ us))))
    combine {u} {u'} {[]}      {us} {[]}     u>u' _ _  >-nil                                                      >-sorted-ys = >-sorted-ys
    combine {u} {u'} {[]}      {us} {vs}     u>u' _ _  >-nil                                                      >-sorted-ys = >-sorted-ys
    combine {u} {u'} {t ∷ []} {us} {v ∷ vs} u>u'  (flat-[] _ flat-u≡[]) (flat-[] _ flat-u'≡[]) (>-cons _ _ >-sorted-map-pair-u-ts u-t>head-map-pair-u-ts)  >-sorted-ys =
      >-cons (PairU u t) (List.foldr _++_ [] (List.map (λ u₂ → List.map (PairU u₂) (v ∷ vs)) (u' ∷ us))) >-sorted-ys (>-just (PairU u t) (PairU u' v) (seq₁w-≡ flat-u≡[] flat-u'≡[] u>u'))
    combine {u} {u'} {t ∷ t' ∷ ts} {us} {vs} u>u' (flat-[] _ flat-u≡[]) (flat-[] _ flat-u'≡[]) (>-cons _ _ >-sorted-map-pair-u-tts u-t>head-map-pair-u-tts) >-sorted-ys =
      >-cons (PairU u t) (List.map (PairU u) (t' ∷ ts) ++ List.foldr _++_ [] (List.map (λ u₂ → List.map (PairU u₂) vs) (u' ∷ us))) ind-hyp' u-t>head-map-pair-u-tts
      where
        ind-hyp' : >-sorted {l ● r ` loc } ((List.map (PairU {l} {r} {loc} u) (t' ∷ ts))  ++ (List.foldr _++_ [] (List.map (λ u₁ → List.map (PairU u₁) vs) (u' ∷ us))))
        ind-hyp' = combine {u} {u'} {t' ∷ ts} {us} {vs} u>u' (flat-[] _ flat-u≡[]) (flat-[] _ flat-u'≡[])  >-sorted-map-pair-u-tts >-sorted-ys
    -- the following is impossible to be reached actually, since ts is a subfix of vs
    combine {u} {u'} {t∷[]}   {us}  {[]}    u>u' (flat-[] _ flat-u≡[]) (flat-[] _ flat-u'≡[]) >-sorted-xs  >-sorted-ys
      rewrite (cong (λ x → >-sorted (List.map (PairU {l} {r} {loc} u) t∷[] ++ x )) (foldr++ys-map-λ_→[]-xs≡ys us []) )
      | (cong (λ x → >-sorted x) ( ++-identityʳ (List.map (PairU {l} {r} {loc} u) t∷[]) ))                                   = >-sorted-xs


-- main lemma and its proof
mkAllEmptyU-sorted : ∀ { r : RE }
  → ( ε∈r : ε∈ r)
  → >-sorted (mkAllEmptyU {r} ε∈r) 
mkAllEmptyU-sorted {$ c ` loc }         = λ()
mkAllEmptyU-sorted {ε}             ε∈ε = >-cons EmptyU     [] >-nil (>-nothing EmptyU)
mkAllEmptyU-sorted {r * nε ` loc}  ε∈* = >-cons (ListU []) [] >-nil (>-nothing (ListU []))
mkAllEmptyU-sorted {l + r  ` loc}  (ε∈ ε∈l <+ ε∉r) = map-leftU-sorted es ind-hyp
  where
    es : List (U l)
    es = mkAllEmptyU ε∈l 
    ind-hyp : >-sorted  (mkAllEmptyU ε∈l)
    ind-hyp = mkAllEmptyU-sorted {l} ε∈l
mkAllEmptyU-sorted {l + r  ` loc}  (ε∈ ε∉l +> ε∈r) = map-rightU-sorted es ind-hyp
  where
    es : List (U r)
    es = mkAllEmptyU ε∈r 
    ind-hyp : >-sorted  (mkAllEmptyU ε∈r)
    ind-hyp = mkAllEmptyU-sorted {r} ε∈r
mkAllEmptyU-sorted {l + r  ` loc}  (ε∈ ε∈l + ε∈r) =  map-leftU-rightU-sorted l-es r-es l-ind-hyp r-ind-hyp
  where
    r-es : List (U r)
    r-es = mkAllEmptyU ε∈r 
    r-ind-hyp : >-sorted  (mkAllEmptyU ε∈r)
    r-ind-hyp = mkAllEmptyU-sorted {r} ε∈r

    l-es : List (U l)
    l-es = mkAllEmptyU ε∈l
    l-ind-hyp : >-sorted  (mkAllEmptyU ε∈l)
    l-ind-hyp = mkAllEmptyU-sorted {l} ε∈l
mkAllEmptyU-sorted {l ● r ` loc }  (ε∈ ε∈l ● ε∈r ) = map-pairU-empty-sorted l-es r-es (mkAllEmptyU-sound {l} ε∈l) l-ind-hyp r-ind-hyp
  where
    r-es : List (U r)
    r-es = mkAllEmptyU ε∈r 
    r-ind-hyp : >-sorted  (mkAllEmptyU ε∈r)
    r-ind-hyp = mkAllEmptyU-sorted {r} ε∈r
    

    l-es : List (U l)
    l-es = mkAllEmptyU ε∈l
    l-ind-hyp : >-sorted  (mkAllEmptyU ε∈l)
    l-ind-hyp = mkAllEmptyU-sorted {l} ε∈l
```



### Definition 30: >-Strict increasing PDInstance

Let r be a non problematic regular expression.
Let c be a letter.
Let pdi be a PDInstance  w.r.t r and c.
We say pdi is >-inc (strict increasing) iff, 
  1. p is the partial derivative inhabited in pdi, and
  2. inj is the injection function from parse trees of p to parse trees of r.
  3. for all parse trees of p, u₁ and u₂ |u₁| = |u₂| where p ⊢ u₁ > u₂
  Then r ⊢ inj u₁ > inj u₂ 

```agda

data >-Inc : ∀ { r : RE } { c : Char } →  PDInstance r c  → Set where
  >-inc : ∀ { p r : RE } { c : Char } { inj : U p →  U r }
    { sound-ev : ∀ ( x : U p ) → ( proj₁ ( flat {r} (inj x) ) ≡ c ∷ ( proj₁ (flat {p} x) )) }
    → ( (u₁ : U p) → (u₂ : U p) → proj₁ (flat u₁) ≡ proj₁ (flat u₂) →  p ⊢ u₁ > u₂  → r ⊢ inj u₁ > inj u₂ ) -- strict increasing evidence 
    → >-Inc {r} {c} (pdinstance {p} {r} {c} inj sound-ev)
```

### Lemma 31: all pdinstances from pdU[ r , c ] are >-strict increasing .

Let r be a  non problematic regular expression.
Let c be a letter.
Then for all pdi ∈ pdU[ r , c], pdi is >-strict increasing .


```agda
>-inc-map-left : ∀ { l r : RE } { loc : ℕ } { c : Char }
    → ( pdis : List (PDInstance l c) )
    → All (>-Inc {l} {c}) pdis
    → All (>-Inc {l + r ` loc } {c}) (List.map pdinstance-left pdis)
>-inc-map-left [] [] = []
>-inc-map-left {l} {r} {loc} {c} ((pdinstance {p} {l} {c}  inj sound-ev) ∷ pdis)
  (>-inc u₁→u₂→proj₁flat-u₁≡proj₁flat-u₂→u₁>u₂→inj-u₁>inj-u₂ ∷ pxs)
  = >-inc >-inc-ev   ∷ >-inc-map-left pdis pxs
  where
    >-inc-ev : ∀ (u₁ : U p)
              → (u₂ : U p)
              → (proj₁ (flat u₁) ≡ proj₁ (flat u₂)) 
              → p ⊢ u₁ > u₂
              --------------
              → (l + r ` loc) ⊢ LeftU (inj u₁) > LeftU (inj u₂)
    >-inc-ev u₁ u₂ proj₁flat-u₁≡proj₁flat-u₂ u₁>u₂ =
      let inj-u₁>inj-u₂ = u₁→u₂→proj₁flat-u₁≡proj₁flat-u₂→u₁>u₂→inj-u₁>inj-u₂ u₁ u₂ proj₁flat-u₁≡proj₁flat-u₂ u₁>u₂
      in choice-ll inj-u₁>inj-u₂



>-inc-map-right : ∀ { l r : RE } { loc : ℕ } { c : Char }
    → ( pdis : List (PDInstance r c) )
    → All (>-Inc {r} {c}) pdis
    → All (>-Inc {l + r ` loc } {c}) (List.map pdinstance-right pdis)
>-inc-map-right [] [] = []
>-inc-map-right {l} {r} {loc} {c} ((pdinstance {p} {r} {c} inj sound-ev) ∷ pdis)
  (>-inc  u₁→u₂→proj₁flat-u₁≡proj₁flat-u₂→u₁>u₂→inj-u₁>inj-u₂ ∷ pxs)
  = >-inc >-inc-ev  ∷ >-inc-map-right pdis pxs
  where
    >-inc-ev : ∀ (u₁ : U p)
              → (u₂ : U p)
              → (proj₁ (flat u₁) ≡ proj₁ (flat u₂))               
              → p ⊢ u₁ > u₂
              --------------
              → (l + r ` loc) ⊢ RightU (inj u₁) > RightU (inj u₂)
    >-inc-ev u₁ u₂ proj₁flat-u₁≡proj₁flat-u₂ u₁>u₂ =
      let inj-u₁>inj-u₂ = u₁→u₂→proj₁flat-u₁≡proj₁flat-u₂→u₁>u₂→inj-u₁>inj-u₂ u₁ u₂ proj₁flat-u₁≡proj₁flat-u₂ u₁>u₂
      in choice-rr inj-u₁>inj-u₂



>-inc-map-fst : ∀ { l r : RE } { loc : ℕ } { c : Char }
               → ( pdis : List (PDInstance l c ) )
               → All (>-Inc {l} {c}) pdis
               → All (>-Inc {l ● r ` loc} {c}) (List.map (pdinstance-fst {l} {r} {loc} {c}) pdis)
>-inc-map-fst [] [] = []
>-inc-map-fst {l} {r} {loc} {c} ((pdinstance {p} {l} {c}  inj sound-ev) ∷ pdis) (>-inc u₁→u₂→u₁>u₂→inj-u₁>inj-u₂ ∷ pxs)
  = (>-inc >-inc-ev)  ∷  >-inc-map-fst pdis pxs
  where
    injFst : U (p ● r ` loc)   → U (l ● r ` loc )
    injFst = mkinjFst inj
    >-inc-ev : ∀ (uv₁ : U ( p ● r ` loc ))
              → (uv₂ : U ( p ● r ` loc ))
              → (proj₁ (flat uv₁) ≡ proj₁ (flat uv₂))                             
              → (p ● r ` loc )  ⊢ uv₁ > uv₂
              ------------------------------------
              → (l ● r ` loc) ⊢ (injFst uv₁) > (injFst uv₂)
    >-inc-ev (PairU u₁ v₁)  (PairU u₂ v₂) proj₁flat-uv₁≡proj₁flat-uv₂ (seq₁w-≡ proj₁flat-u₁≡proj₁flat-u₂   u₁>u₂) =
      seq₁w-≡ ?  inj-u₁>inj-u₂
      where
        inj-u₁>inj-u₂ = u₁→u₂→u₁>u₂→inj-u₁>inj-u₂ u₁ u₂ ?  u₁>u₂ -- since u1=u2=[] => |v1|=|v2|
        inj-u₁≡¬[] : ¬ ( proj₁ (flat (inj u₁)) ≡ [])
        inj-u₁≡¬[] rewrite (sound-ev u₁) = λ () 
        inj-u₂≡¬[] : ¬ ( proj₁ (flat (inj u₂)) ≡ [])
        inj-u₂≡¬[] rewrite (sound-ev u₂)  = λ()          

    >-inc-ev (PairU u₁ v₁)  (PairU u₂ v₂) proj₁flat-uv₁≡proj₁flat-uv₂ (seq₂  u₁≡u₂ v₁>v₂ ) = (seq₂ inj-u₁≡inj-u₂ v₁>v₂)  
        where
          inj-u₁≡inj-u₂ : inj u₁ ≡ inj u₂ 
          inj-u₁≡inj-u₂ = cong inj u₁≡u₂
          
    >-inc-ev (PairU u₁ v₁) (PairU u₂ v₂) proj₁flat-uv₁≡proj₁flat-uv₂ (seq₁pref ( c , ( cs , proj₁flat-u₁≡proj₁-flat-u₂++ccs ) )) =
      seq₁pref ? 
           -- would it be possible if u1 = R [a], v1 = [] and u2 = L [], v2 = [a]
           -- inj u1 = R [a, a] and inj u2 = L [a]
           -- not possible, >-inc the pdinstance {l} {c} ensure that u₁>u₂
           -- and nothing of the pdinstance can inject values of both  R x and L y 
      where
        inj-u₁>inj-u₂ = u₁→u₂→u₁>u₂→inj-u₁>inj-u₂ u₁ u₂ {!!} 
        inj-u₁≡¬[] : ¬ ( proj₁ (flat (inj u₁)) ≡ [])
        inj-u₁≡¬[] rewrite (sound-ev u₁) = λ()
        inj-u₂≡¬[] : ¬ ( proj₁ (flat (inj u₂)) ≡ [])
        inj-u₂≡¬[] rewrite (sound-ev u₂) = λ()
    
-----------------------------------------------------------------------------------------
-- aux lemma to show that injSnd is >-strict increasing
>-inc-injSnd : ∀ {l r p : RE } { loc : ℕ }
         → ( v : U l )
         → ( inj : U p → U r )         
         → ( u₁ : U p )
         → ( u₂ : U p )
         → r ⊢ inj u₁ > inj u₂
         --------------------------------------------------------------------------
         → ( l ● r ` loc ) ⊢  (mkinjSnd inj v u₁) > (mkinjSnd inj v u₂) 
>-inc-injSnd {l} {r} {p} {loc} v inj u₁ u₂ inj-u₁>inj-u₂ = seq₂ refl inj-u₁>inj-u₂

-- aux lemma to show that mk-snd-pdi is >-strict increasing
>-inc-mk-snd-pdi : ∀ { l r : RE } { loc : ℕ } { c : Char }
   → ( e-flat-[]-e : (∃[ e ] Flat-[] l e)  )
   → ( pdi : PDInstance r c )
   → >-Inc {r} {c} pdi 
   -------------------------------------------------------------------
   → >-Inc (mk-snd-pdi {l} {r} {loc} {c} e-flat-[]-e pdi) 
>-inc-mk-snd-pdi {l} {r} {loc} {c} (e , flat-[] e' proj₁∘flate≡[]) (pdinstance {p} {r} {c} inj s-ev) (>-inc >-inc-inj) =
  >-inc (λ u₁ u₂ u₁>u₂ → ( >-inc-injSnd {l} {r} {p} {loc} e inj u₁ u₂  (>-inc-inj u₁ u₂ u₁>u₂))  )
  where
    -- duplicated from mk-snd-pdi from PartialDerivativeParseTree so that the PDInstance can be inferred
    -- this is needed because p is an existential type `hidden` inside PDInstance r c 
    injSnd :  U p → U (l ● r ` loc)
    injSnd = mkinjSnd {l} {r} {p} {loc} inj e
    injSnd-s-ev =
      (λ u → 
           begin
             proj₁ (flat (PairU {l} {r} {loc} e (inj u)))
           ≡⟨⟩
             (proj₁ (flat e)) ++ (proj₁ (flat (inj u)))
           ≡⟨ cong (λ x → ( x ++  (proj₁ (flat (inj u))))) proj₁∘flate≡[] ⟩  --  e must be an empty; we do have flat v ≡ [] from mkAllEmptyU-sound
             [] ++ (proj₁ (flat (inj u)))
           ≡⟨⟩
             proj₁ (flat (inj u))
           ≡⟨ s-ev u ⟩
             c ∷ (proj₁ (flat u))
           ∎
          )    

-- aux lemma to show that concatMap pdinstance-snd  is >-strict increasing

>-inc-pdinstance-snd : ∀ { l r : RE } { ε∈l : ε∈ l } { loc : ℕ } { c : Char }
  → ( e-flat-[]-e : ∃[ e ] Flat-[] l e )
  → ( pdis : List (PDInstance r c ) )
  → All (>-Inc {r} {c}) pdis
  ---------------------------------------------------------------------------
  → All  (>-Inc {l ● r ` loc} {c}) (List.map  (mk-snd-pdi e-flat-[]-e ) pdis )
>-inc-pdinstance-snd {l} {r} {ε∈l} {loc} {c} e-flat-[]-e []           [] = [] 
>-inc-pdinstance-snd {l} {r} {ε∈l} {loc} {c} e-flat-[]-e (pdi ∷ pdis) (>-inc-pdi ∷ all>-inc-pdis) = (>-inc-mk-snd-pdi e-flat-[]-e pdi >-inc-pdi) ∷ >-inc-pdinstance-snd {l} {r} {ε∈l} {loc} {c} e-flat-[]-e pdis all>-inc-pdis

>-inc-concatmap-pdinstance-snd-sub :  ∀ { l r : RE } { ε∈l : ε∈ l } { loc : ℕ } { c : Char }
  → ( e-flat-[]-es  : List ( ∃[ e ] Flat-[] l e ) )
  → ( pdis : List (PDInstance r c ) )
  → All (>-Inc {r} {c}) pdis
  -----------------------------------------------------------------------------------------------------
  → All (>-Inc {l ● r ` loc} {c}) (concatMap (λ x → pdinstance-snd {l} {r} {loc} {c} x  pdis) e-flat-[]-es)
>-inc-concatmap-pdinstance-snd-sub {l} {r} {ε∈l} {loc} {c} [] _ _ = []
>-inc-concatmap-pdinstance-snd-sub {l} {r} {ε∈l} {loc} {c} ( e-flat-[]-e ∷ e-flat-[]-es ) pdis all>-inc-pdis =
  all-concat  (>-inc-pdinstance-snd {l} {r} {ε∈l} {loc} {c}  e-flat-[]-e  pdis all>-inc-pdis)
              (>-inc-concatmap-pdinstance-snd-sub {l} {r} {ε∈l} {loc} {c} e-flat-[]-es pdis all>-inc-pdis)  


>-inc-concatmap-pdinstance-snd : ∀ { l r : RE } { ε∈l : ε∈ l } { loc : ℕ } { c : Char }
               → ( pdis : List (PDInstance r c ) )
               → All (>-Inc {r} {c}) pdis
               → All (>-Inc {l ● r ` loc} {c}) (concatmap-pdinstance-snd {l} {r} {ε∈l} {loc} {c}  pdis)
>-inc-concatmap-pdinstance-snd {l} {r} {ε∈l} {loc} {c} pdis all>-inc-pdis = >-inc-concatmap-pdinstance-snd-sub  {l} {r} {ε∈l} {loc} {c} (zip-es-flat-[]-es {l} {ε∈l} es flat-[]-es) pdis all>-inc-pdis
  where
    es : List (U l)
    es = mkAllEmptyU {l} ε∈l
    flat-[]-es : All (Flat-[] l) es
    flat-[]-es = mkAllEmptyU-sound {l} ε∈l    




>-inc-map-star : ∀ { r : RE } { ε∉r : ε∉ r } { loc : ℕ } { c : Char }
               → ( pdis : List (PDInstance r c)  )
               → All (>-Inc {r} {c}) pdis
               → All (>-Inc {r * ε∉r ` loc} {c}) (List.map (pdinstance-star {r} {ε∉r} {loc} {c}) pdis)
>-inc-map-star {r} {ε∉r} {loc} {c} [] [] = []
>-inc-map-star {r} {ε∉r} {loc} {c} (pdinstance {p} {r} {c} inj s-ev ∷ pdis) (>-inc >-ev ∷ pxs)  =
  >-inc >-inc-ev ∷ >-inc-map-star pdis pxs
  where
    injList : U (p ● (r * ε∉r ` loc ) ` loc ) → U ( r * ε∉r ` loc )
    injList = mkinjList inj   

    >-inc-ev : ∀ (uv₁ : U ( p ● (r * ε∉r ` loc ) ` loc ))
              → (uv₂ : U ( p ● (r * ε∉r ` loc ) ` loc ))
              → (proj₁ (flat uv₁) ≡ proj₁ (flat uv₂))                                           
              → (p ● (r * ε∉r ` loc ) ` loc )  ⊢ uv₁ > uv₂
              ------------------------------------
              → (r * ε∉r ` loc) ⊢ (injList uv₁) > (injList uv₂)
    >-inc-ev (PairU u₁ (ListU vs₁))  (PairU u₂ (ListU vs₂)) proj₁flat-uv₁≡proj₁flat-uv₂ (seq₁w-≡ proj₁flat-u₁≡proj₁flat-u₂  u₁>u₂) = 
      let inj-u₁>inj-u₂ = >-ev u₁ u₂ u₁>u₂
      in star-head {r} {loc} {ε∉r} {inj u₁} {inj u₂} {vs₁} {vs₂} inj-u₁>inj-u₂
    >-inc-ev (PairU u₁ (ListU vs₁))  (PairU u₂ (ListU vs₂)) proj₁flat-uv₁≡proj₁flat-uv₂ (seq₁pref ( c , cs , proj₁flat-u₁≡proj₁flat-u₂++ccs )) = 
      let inj-u₁>inj-u₂ = >-ev u₁ u₂ {!!} -- TODO: we can't use >-ev here, which >-ev : (u₃ u₄ : U p) → p ⊢ u₃ > u₄ → r ⊢ inj u₃ > inj u₄
                                          -- we need something stronger, >-inj : (u₃ u₄ : U p) → ¬ (Flat-[] p u₃) →  (Flat-[] p u₄) → inj u₃ > inj u₄
                                          -- but inj is "hidden" existentially inside PDinstance 
      in star-head {r} {loc} {ε∉r} {inj u₁} {inj u₂} {vs₁} {vs₂} inj-u₁>inj-u₂
    >-inc-ev (PairU u₁ (ListU vs₁))  (PairU u₂ (ListU vs₂)) (seq₂  u₁≡u₂ list-vs₁>list-vs₂ ) =
      (star-tail inj-u₁≡inj-u₂ list-vs₁>list-vs₂)  
        where
          inj-u₁≡inj-u₂ : inj u₁ ≡ inj u₂ 
          inj-u₁≡inj-u₂ = cong inj u₁≡u₂

-- main lemma proof
pdU->-inc : ∀ { r : RE } { c : Char }
  → All (>-Inc {r} {c}) pdU[ r , c ]
pdU->-inc {ε} {c} = []
pdU->-inc {$ c ` loc} {c'} with c Char.≟ c'
...  | no ¬c≡c' = []
...  | yes refl =  ( >-inc (λ { EmptyU EmptyU →  λ() } ) ) ∷ []
pdU->-inc {l + r ` loc} {c} = all-concat map-ind-hyp-l map-ind-hyp-r 
  where
    ind-hyp-l : All (>-Inc {l} {c}) pdU[ l , c ]
    ind-hyp-l = pdU->-inc {l} {c}
    
    ind-hyp-r : All (>-Inc {r} {c}) pdU[ r , c ]
    ind-hyp-r = pdU->-inc {r} {c}     

    map-ind-hyp-l : All (>-Inc {l + r ` loc} {c}) (List.map pdinstance-left pdU[ l , c ])
    map-ind-hyp-l = >-inc-map-left pdU[ l , c ]  ind-hyp-l

    map-ind-hyp-r : All (>-Inc {l + r ` loc} {c}) (List.map pdinstance-right pdU[ r , c ])
    map-ind-hyp-r = >-inc-map-right pdU[ r , c ]  ind-hyp-r
pdU->-inc {l ● r ` loc} {c} with ε∈? l
...                           | no ¬ε∈l = >-inc-map-fst pdU[ l , c ] ind-hyp-l
  where 
    ind-hyp-l : All (>-Inc {l} {c}) pdU[ l , c ]
    ind-hyp-l = pdU->-inc {l} {c}
    
pdU->-inc {l ● r ` loc} {c}  | yes ε∈l = all-concat  all->-inc-pdis-inj-from-l-c all->-inc-concatmap-pdinstance-snd
  where
    ind-hyp-l : All (>-Inc {l} {c}) pdU[ l , c ]
    ind-hyp-l = pdU->-inc {l} {c}

    all->-inc-pdis-inj-from-l-c : All (>-Inc {l ● r ` loc} {c}) (List.map (pdinstance-fst {l} {r} {loc} {c}) pdU[ l , c ])
    all->-inc-pdis-inj-from-l-c =  >-inc-map-fst pdU[ l , c ] ind-hyp-l
    
    ind-hyp-r : All (>-Inc {r} {c}) pdU[ r , c ]
    ind-hyp-r = pdU->-inc {r} {c}

    all->-inc-concatmap-pdinstance-snd : All (>-Inc {l ● r ` loc} {c}) (concatmap-pdinstance-snd  pdU[ r , c ])
    all->-inc-concatmap-pdinstance-snd  = >-inc-concatmap-pdinstance-snd pdU[ r , c ] ind-hyp-r
pdU->-inc {r * ε∉r ` loc } {c} = all->-inc-map-star
  where
    ind-hyp-r : All (>-Inc {r} {c}) pdU[ r , c ]
    ind-hyp-r = pdU->-inc {r} {c}

    all->-inc-map-star : All (>-Inc {r * ε∉r ` loc} {c}) (List.map (pdinstance-star {r} {ε∉r} {loc} {c})  pdU[ r , c ])
    all->-inc-map-star  = >-inc-map-star pdU[ r , c ] ind-hyp-r


```



### Definition 32: >-Strict increaseing PDInstance*

Let r be a non problematic regular expression.
Let w be a word.
Let pdi be a PDInstance* w.r.t r and w.
We say pdi is >-inc (strict increasing) iff,
  1. p be the partial derivative descendant inhabited in pdi, and
  2. inj is the injection function from parse tress of p to parse tress of r.
  3. for all parse trees p, u₁ and u₂ where p ⊢ u₁ > u₂
  Then r ⊢ inj u₁ > inj u₂





### Lemma 33 : all pdinstance*'s from pdUMany[ r , w ] are >-strict increasing .

Let r be a non problematic regular expression.
Let w be a word.
Then for all pdi ∈ pdUMany[ r , w ], pdi is >-strict increasing. 
